<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASCII 表(控制字符和可显示字符)</title>
    <url>/Appendix/ASCII/</url>
    <content><![CDATA[<p>ASCII（American Standard Code for Information Interchange，美国信息互换标准代码，ASCII）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。</p>
<p>ASCII第一次以规范标准的型态发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符，其中33个字符无法显示（这是以现今操作系统为依归，但在DOS模式下可显示出一些诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符，控制字符的用途主要是用来操控已经处理过的文字，在33个字符之外的是95个可显示的字符，包含用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。</p>
<span id="more"></span>
<figure>
<img src="/Appendix/ASCII/ASCII_1.png" alt="ASCII"><figcaption aria-hidden="true">ASCII</figcaption>
</figure>
<p>下面是ASCII控制字符在DOS系统下的ASCII表 <img src="/Appendix/ASCII/ASCII_2.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Appendix</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML special symbol</title>
    <url>/Appendix/HTML-special-symbol/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">α</td>
<td style="text-align: center;">&amp;alpha；</td>
<td style="text-align: center;">β</td>
<td style="text-align: center;">&amp;beta；</td>
<td style="text-align: center;">χ</td>
<td style="text-align: center;">&amp;chi；</td>
</tr>
<tr class="even">
<td style="text-align: center;">δ</td>
<td style="text-align: center;">&amp;delta；</td>
<td style="text-align: center;">ε</td>
<td style="text-align: center;">&amp;epsilon；</td>
<td style="text-align: center;">η</td>
<td style="text-align: center;">&amp;eta；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">γ</td>
<td style="text-align: center;">&amp;gamma；</td>
<td style="text-align: center;">ι</td>
<td style="text-align: center;">&amp;iota；</td>
<td style="text-align: center;">κ</td>
<td style="text-align: center;">&amp;kappa；</td>
</tr>
<tr class="even">
<td style="text-align: center;">λ</td>
<td style="text-align: center;">&amp;lambda；</td>
<td style="text-align: center;">μ</td>
<td style="text-align: center;">&amp;mu；</td>
<td style="text-align: center;">ν</td>
<td style="text-align: center;">&amp;nu；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ω</td>
<td style="text-align: center;">&amp;omega；</td>
<td style="text-align: center;">ο</td>
<td style="text-align: center;">&amp;omicron；</td>
<td style="text-align: center;">φ</td>
<td style="text-align: center;">&amp;phi；</td>
</tr>
<tr class="even">
<td style="text-align: center;">π</td>
<td style="text-align: center;">&amp;pi；</td>
<td style="text-align: center;">ψ</td>
<td style="text-align: center;">&amp;psi；</td>
<td style="text-align: center;">ρ</td>
<td style="text-align: center;">&amp;rho；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">σ</td>
<td style="text-align: center;">sigma；</td>
<td style="text-align: center;">τ</td>
<td style="text-align: center;">&amp;tau；</td>
<td style="text-align: center;">θ</td>
<td style="text-align: center;">&amp;theta；</td>
</tr>
<tr class="even">
<td style="text-align: center;">υ</td>
<td style="text-align: center;">&amp;upsilon；</td>
<td style="text-align: center;">ξ</td>
<td style="text-align: center;">&amp;xi；</td>
<td style="text-align: center;">ζ</td>
<td style="text-align: center;">&amp;zeta；</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<hr>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Α</td>
<td style="text-align: center;">&amp;Alpha；</td>
<td style="text-align: center;">Β</td>
<td style="text-align: center;">&amp;Beta；</td>
<td style="text-align: center;">Χ</td>
<td style="text-align: center;">&amp;Chi；</td>
</tr>
<tr class="even">
<td style="text-align: center;">Δ</td>
<td style="text-align: center;">&amp;Delta；</td>
<td style="text-align: center;">Ε</td>
<td style="text-align: center;">&amp;Epsilon；</td>
<td style="text-align: center;">Η</td>
<td style="text-align: center;">&amp;Eta；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Γ</td>
<td style="text-align: center;">&amp;Gamma；</td>
<td style="text-align: center;">Ι</td>
<td style="text-align: center;">&amp;Iota；</td>
<td style="text-align: center;">Κ</td>
<td style="text-align: center;">&amp;Kappa；</td>
</tr>
<tr class="even">
<td style="text-align: center;">Λ</td>
<td style="text-align: center;">&amp;Lambda；</td>
<td style="text-align: center;">Μ</td>
<td style="text-align: center;">&amp;Mu；</td>
<td style="text-align: center;">Ν</td>
<td style="text-align: center;">&amp;Nu；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Ω</td>
<td style="text-align: center;">&amp;Omega；</td>
<td style="text-align: center;">Ο</td>
<td style="text-align: center;">&amp;Omicron；</td>
<td style="text-align: center;">Φ</td>
<td style="text-align: center;">&amp;Phi；</td>
</tr>
<tr class="even">
<td style="text-align: center;">Π</td>
<td style="text-align: center;">&amp;Pi；</td>
<td style="text-align: center;">Ψ</td>
<td style="text-align: center;">&amp;Psi；</td>
<td style="text-align: center;">Ρ</td>
<td style="text-align: center;">&amp;Rho；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Σ</td>
<td style="text-align: center;">&amp;Sigma；</td>
<td style="text-align: center;">Τ</td>
<td style="text-align: center;">&amp;Tau；</td>
<td style="text-align: center;">Θ</td>
<td style="text-align: center;">&amp;Theta；</td>
</tr>
<tr class="even">
<td style="text-align: center;">Υ</td>
<td style="text-align: center;">&amp;Upsilon；</td>
<td style="text-align: center;">Ξ</td>
<td style="text-align: center;">&amp;Xi；</td>
<td style="text-align: center;">Ζ</td>
<td style="text-align: center;">&amp;Zeta；</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">€</td>
<td style="text-align: center;">&amp;euro；</td>
<td style="text-align: center;">£</td>
<td style="text-align: center;">&amp;pound；</td>
<td style="text-align: center;">¥</td>
<td style="text-align: center;">&amp;yen；</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">©</td>
<td style="text-align: center;">&amp;copy；</td>
<td style="text-align: center;">°</td>
<td style="text-align: center;">&amp;deg；</td>
<td style="text-align: center;">÷</td>
<td style="text-align: center;">&amp;divide；</td>
</tr>
<tr class="even">
<td style="text-align: center;">⅓</td>
<td style="text-align: center;">&amp;frac13；</td>
<td style="text-align: center;">¼</td>
<td style="text-align: center;">&amp;frac14；</td>
<td style="text-align: center;">®</td>
<td style="text-align: center;">&amp;reg；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">§</td>
<td style="text-align: center;">&amp;sect；</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">&amp;times；</td>
<td style="text-align: center;">™</td>
<td style="text-align: center;">&amp;trade；</td>
</tr>
<tr class="even">
<td style="text-align: center;">•</td>
<td style="text-align: center;">&amp;bull；</td>
<td style="text-align: center;">¢</td>
<td style="text-align: center;">&amp;cent；</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">编码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">≈</td>
<td style="text-align: center;">&amp;asymp；</td>
<td style="text-align: center;">≥</td>
<td style="text-align: center;">&amp;ge；</td>
<td style="text-align: center;">≤</td>
<td style="text-align: center;">&amp;le；</td>
</tr>
<tr class="even">
<td style="text-align: center;">≠</td>
<td style="text-align: center;">&amp;ne；</td>
<td style="text-align: center;">∑</td>
<td style="text-align: center;">&amp;sum；</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">&amp;radic；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">♣</td>
<td style="text-align: center;">&amp;clubs；</td>
<td style="text-align: center;">♦</td>
<td style="text-align: center;">&amp;diams；</td>
<td style="text-align: center;">♥</td>
<td style="text-align: center;">&amp;hearts；</td>
</tr>
<tr class="even">
<td style="text-align: center;">♠</td>
<td style="text-align: center;">&amp;spades；</td>
<td style="text-align: center;">↔︎</td>
<td style="text-align: center;">&amp;harr；</td>
<td style="text-align: center;">∩</td>
<td style="text-align: center;">&amp;cap；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">∞</td>
<td style="text-align: center;">&amp;infin；</td>
<td style="text-align: center;">∫</td>
<td style="text-align: center;">&amp;int；</td>
<td style="text-align: center;">↑</td>
<td style="text-align: center;">&amp;uarr；</td>
</tr>
<tr class="even">
<td style="text-align: center;">↓</td>
<td style="text-align: center;">&amp;darr；</td>
<td style="text-align: center;">←</td>
<td style="text-align: center;">&amp;larr；</td>
<td style="text-align: center;">→</td>
<td style="text-align: center;">&amp;rarr；</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Appendix</category>
      </categories>
      <tags>
        <tag>special symbol</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 系列模块介绍</title>
    <url>/Python/Python-%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<center>
python 部分库介绍
</center>
<span id="more"></span>
<h4 id="python-文档链接"><a href="https://docs.python.org/zh-cn/3.7/">python 文档链接</a></h4>
<h4 id="pytorch">PyTorch</h4>
<ol type="1">
<li><p>tensor().nonzero() 方法</p>
<p>返回一个包含输入 <code>input</code> 中非零元素索引的张量.输出张量中的每行包含 <code>input</code> 中非零元素的索引 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.Tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0.6</span>,<span class="number">0</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0.4</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0.7</span>,<span class="number">2</span>]])</span><br><span class="line">(x[:,<span class="number">4</span>:] &gt; <span class="number">0.5</span>).nonzero()</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure> 可以看到，输出值第一行表示<strong>切片</strong>后的数据中第 0 行第 0 个数据满足大于 0.5，第二行表示第 1 行第 1 个数据大于 0.5，...。（这里说的第几行第几列均表示 tensor 索引，从 0 开始）</p></li>
</ol>
<h4 id="glob-模块">glob 模块</h4>
<p>用于路径匹配</p>
<ul>
<li><code>*</code> 匹配一个或多个字符</li>
<li><code>?</code> 匹配单个字符</li>
<li><code>[]</code> 匹配指定范围内字符，如：[0-9]匹配数字</li>
</ul>
<ol type="1">
<li>直接输出列表 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">path = Path(<span class="string">r&#x27;C:\Users\TLDX\Desktop\yolov5-4.0\runs\detect\exp&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(glob.glob(<span class="string">r&#x27;&#123;path&#125;*&#x27;</span>))  <span class="comment"># * 表示匹配所有路径</span></span><br></pre></td></tr></table></figure></li>
<li>输出迭代器 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">path = Path(<span class="string">r&#x27;C:\Users\TLDX\Desktop\yolov5-4.0\runs\detect\exp&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> glob.iglob(<span class="string">r&#x27;&#123;path&#125;*&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(file)</span><br></pre></td></tr></table></figure> <a href="https://docs.python.org/zh-cn/3.7/library/glob.html?highlight=glob#module-glob">参考链接</a></li>
</ol>
<h4 id="argparse-模块">argparse 模块</h4>
<p>Python 内置的一个用于命令项选项与参数解析的模块</p>
<p>主要有三个步骤：</p>
<ul>
<li>创建 ArgumentParser() 对象</li>
<li>调用 add_argument() 方法添加参数</li>
<li>使用 parse_args() 解析添加的参数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"><span class="comment"># 添加属性</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--weights&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;weights/yolov5s.pt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;initial weights path&#x27;</span>) <span class="comment"># 模型训练权重</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">2</span>) <span class="comment"># epoch 次数</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--img-size&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=[<span class="number">640</span>, <span class="number">640</span>], <span class="built_in">help</span>=<span class="string">&#x27;[train, test] image sizes&#x27;</span>) <span class="comment"># 缩放后要训练的图像大小</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--rect&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;rectangular training&#x27;</span>) <span class="comment"># 矩形训练 </span></span><br><span class="line"><span class="comment"># 解析添加的参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="built_in">print</span>(args)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="re-模块">re 模块</h4>
<p>使用正则表达式匹配</p>
<p>参考 <a href="https://www.runoob.com/python3/python3-reg-expressions.html">菜鸟教程</a> 和 <a href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式</a>。</p>
<h4 id="os-模块">os 模块</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.join(p, <span class="string">&#x27;*.*&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可参考 <a href="https://www.runoob.com/python/os-file-methods.html">菜鸟教程</a>。</p>
<h4 id="python-独特使用">python 独特使用</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">images = [x <span class="keyword">for</span> x <span class="keyword">in</span> files <span class="keyword">if</span> x.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>].lower() <span class="keyword">in</span> images_format]</span><br><span class="line"></span><br><span class="line">model(img.half() <span class="keyword">if</span> half <span class="keyword">else</span> img) <span class="keyword">if</span> device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="python-内置函数">python 内置函数</h4>
<ol type="1">
<li>hasattr 函数 用于判断对象是否包含对应的属性 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(<span class="built_in">object</span>, name)</span><br></pre></td></tr></table></figure></li>
<li>getattr 函数 函数用于返回一个对象属性值。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(<span class="built_in">object</span>, name, default)</span><br></pre></td></tr></table></figure>
<ul>
<li>object：对象</li>
<li>name：对象的属性</li>
<li>defaul：当需要查找的属性没有时，提供默认返回值</li>
</ul></li>
<li>setattr 函数 函数用于设置属性值 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setattr</span>(<span class="built_in">object</span>, name, value)</span><br></pre></td></tr></table></figure>
<ul>
<li>object：对象</li>
<li>name：对象的属性</li>
<li>value：属性值</li>
</ul>
如果属性不存在会创建一个新的对象属性，并对属性赋值：</li>
</ol>
<h4 id="yaml">yaml</h4>
<p>一种标记语言，一般用于配置文件的书写</p>
<p>用法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="comment"># 读 yaml 文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file_name&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = yaml.load(f, Loader=FullLoader)</span><br><span class="line"><span class="comment"># 写 yaml 文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file_name&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    yaml.dump(data, f,)</span><br></pre></td></tr></table></figure> <a href="https://www.runoob.com/w3cnote/yaml-intro.html">参考链接</a>。</p>
<h4 id="tqdm">tqdm</h4>
<p>Tqdm 是一个快速，可扩展的Python进度条，可以在 Python 长循环中添加一个进度提示信息，用户只需要封装任意的迭代器 tqdm(iterator)。</p>
<p>可以有以下几种用法 1. ```python from tqdm import tqdm for i in tqdm(range(1000)): pass <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. ```python</span><br><span class="line">   pbar = tqdm([&#x27;a&#x27;, &#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])</span><br><span class="line">   for char in pbar:</span><br><span class="line">      pbar.set_description(&#x27;Processing %s&#x27; % char)</span><br></pre></td></tr></table></figure> <a href="https://tqdm.github.io/docs/tqdm/">参考链接</a></p>
<h4 id="threading">Threading</h4>
<p><a href="https://www.runoob.com/python3/python3-multithreading.html">参考链接</a>。</p>
<h4 id="logging-模块">logging 模块</h4>
<p><a href="https://docs.python.org/zh-cn/3.7/howto/logging.html#logging-basic-tutorial">参考链接</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ primer v5 solutions</title>
    <url>/cpp/c-primer-v5-solutions/</url>
    <content><![CDATA[<center>
c++ primer version 5 题解
</center>
<span id="more"></span>
<h3 id="chapter-1">Chapter 1</h3>
<h4 id="section">1.3</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;Hello, World.&quot;</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-1">1.6</h4>
<p>程序不合法。<code>;</code> 则意味着该语句的结束。第二行的语句则与第一行无关，因此需要重新声明 <code>std::cout&lt;&lt;</code>。</p>
<h4 id="section-2">1.8</h4>
<ol type="1">
<li>合法</li>
<li>合法</li>
<li>非法</li>
<li>合法</li>
</ol>
<h4 id="section-3">1.9</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">50</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-4">1.10</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-5">1.11</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Please input two int numbers:&quot;</span>;</span><br><span class="line">    std::cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">    low = i &gt; j? j:i;</span><br><span class="line">    high = i &gt; j? i:j;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        std::cout&lt;&lt;low&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-6">1.12</h4>
<p>程序是将 -100 到 100 的所有整数相加，<code>sum</code> 终值为 0。</p>
<h4 id="section-7">1.16</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin&gt;&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += value;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chapter-2">Chapter 2</h3>
<h4 id="section-8">2.1</h4>
<ul>
<li><blockquote>
<p>An int, long, long long and short types are representation of integral types of a chunk of allocated memory. The difference between them is in the size of the representation (in bytes) of the respective type, which is often implementation dependent.</p>
</blockquote></li>
<li><blockquote>
<p>The unsigned type represents a positive value, while an unsigned represents both positive an negative values of an integral type (except for bool). The limits range of the value depends on the size of integral type. Given that unsigned holds only positive value, it has a higher max limit.</p>
</blockquote></li>
<li><blockquote>
<p>A float and a double are floating-point types that represent "single-, double-, and extended-precision values." Their representation is implementation dependent. Most compilers follow the IEEE 754 standard at least for float and double.</p>
</blockquote></li>
</ul>
<h4 id="section-9">2.2</h4>
<p>使用 <code>float</code>, <code>double</code> 类型。</p>
<h4 id="section-10">2.5</h4>
<h4 id="section-11">2.6</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&#x27;\115&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-12">2.12</h4>
<ol type="a">
<li>非法；(b) 非法；(c) 非法；(d) 非法；(e) 合法</li>
</ol>
<h4 id="section-13">2.13</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j 为 100</span></span><br></pre></td></tr></table></figure>
<h4 id="section-14">2.14</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; sum &lt;&lt;endl;</span><br><span class="line"><span class="comment">// 将会输出 100 45</span></span><br></pre></td></tr></table></figure>
<h4 id="section-15">2.15</h4>
<ol type="a">
<li>合法；(b) 非法；(c) 合法；(d) 非法</li>
</ol>
<h4 id="section-16">2.16</h4>
<ol type="a">
<li>合法；(b) 合法；(c) 合法；(d) 合法</li>
</ol>
<h4 id="section-17">2.17</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, &amp;ri = i;</span><br><span class="line">i = <span class="number">5</span>; ri = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ri&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// 输出 10 10</span></span><br></pre></td></tr></table></figure>
<h4 id="section-18">2.19</h4>
<p>reference:</p>
<ul>
<li>the use of &amp; before an type declares a reference. E.g.: int &amp;i = i;</li>
<li>not an object in memory</li>
<li>must be initialized</li>
<li>its binding cannot be changed after initial definition</li>
</ul>
<p>pointer:</p>
<ul>
<li>declared with * symbol. E.g.: int *p;</li>
<li>assigned an address with an assign operator. E.g.: p = &amp;a;</li>
<li>assigned the value to which a pointer points to is dereferenced with <em>. E.g.: b = </em>p</li>
<li>is an object in memory</li>
<li>can be declared but not initialized</li>
<li>holds an address as a value</li>
<li>its value can be change to point to another address</li>
<li>can be used in pointer asthmatics</li>
</ul>
<h4 id="section-19">2.20</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line">*pi = *pi * *pi;</span><br><span class="line"><span class="comment">// 等价于 i = i * i</span></span><br></pre></td></tr></table></figure>
<h4 id="section-20">2.24</h4>
<blockquote>
<p>p is a pointer to void pointing to an int, while lp is a pointer to a long pointing to an int. p is legal and lp is not because a pointer must match the type of object it is pointing to, unless it is a void pointer.</p>
</blockquote>
<h4 id="section-21">2.26</h4>
<ol type="a">
<li>非法；(b) 合法；(c) 合法；(d) 合法；非法</li>
</ol>
<h3 id="chapter-3">Chapter 3</h3>
<h4 id="section-22">3.2</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, word))&#123;</span><br><span class="line">        cout&lt;&lt;word&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-23">3.3</h4>
<ul>
<li><code>string</code> 类将空白字符视为字符串的结束标志。</li>
<li><code>getline</code> 函数将回车键视为读入的结束标志。</li>
</ul>
<h4 id="section-24">3.4</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">if</span>(s1 == s2)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;相等&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s1 &gt; s2)</span><br><span class="line">        cout&lt;&lt;s1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-25">3.5</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, output;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s1)&#123;</span><br><span class="line">        output += s1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;output;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-26">3.6</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;TLDX&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s1)</span><br><span class="line">        c = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-27">3.10</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;TLDX!TLDX!TLDX!&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : s1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">ispunct</span>(c))</span><br><span class="line">            cout&lt;&lt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-28">3.11</h4>
<p>合法。c 的类型为 const char &amp;</p>
<h4 id="section-29">3.12</h4>
<ol type="a">
<li>正确；(b) 错误；(c) 正确</li>
</ol>
<h4 id="section-30">3.13</h4>
<ol type="a">
<li>0；(b) 10；(c) 10；(d) 1；(e) 2；(f) 10；(g) 10</li>
</ol>
<h4 id="section-31">3.14</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a)&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(a); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">        cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-32">3.15</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a)&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(a); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">        cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-33">3.17</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; s1;</span><br><span class="line">    string s2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s2 )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : s2)&#123;</span><br><span class="line">            i = <span class="built_in">toupper</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">push_back</span>(s2);</span><br><span class="line">        cout&lt;&lt;s2&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-34">3.18</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不合法，修改为：</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">ivec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h4 id="section-35">3.19</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我更推荐第一种</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; s1 = (<span class="number">10</span>, <span class="number">42</span>); <span class="comment">//第一种</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; s1 = &#123;<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>&#125;; <span class="comment">//第二种</span></span><br><span class="line">vecrot&lt;<span class="keyword">int</span>&gt; s1; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) s1.<span class="built_in">push_back</span>(<span class="number">42</span>); <span class="comment">//第三种</span></span><br></pre></td></tr></table></figure>
<h4 id="section-36">3.20</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">    <span class="keyword">while</span>( cin&gt;&gt;a )</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(a);</span><br><span class="line">    <span class="keyword">int</span> size = ivec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size<span class="number">-1</span>; i++)</span><br><span class="line">        cout&lt;&lt;ivec[i] + ivec[i+<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size/<span class="number">2</span>; i++)</span><br><span class="line">        cout&lt;&lt;ivec[i] + ivec[size-i<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-37">3.22</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; s1;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">getline</span>(cin, line))&#123;</span><br><span class="line">        s1.<span class="built_in">push_back</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s1.<span class="built_in">cbegin</span>(); it != s1.<span class="built_in">cend</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : *it)&#123;</span><br><span class="line">            c = <span class="built_in">toupper</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-38">3.23</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        cin&gt;&gt;c;</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        *it = *it * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-39">3.25</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="keyword">auto</span> it = scores.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>( cin&gt;&gt;grade)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grade &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            ++*(it + grade/<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : scores)</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-40">3.26</h4>
<p>因为两个迭代器相加得到的并非迭代器，是非法结果。</p>
<h4 id="section-41">3.31</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-42">3.33</h4>
<p>如果 <code>scores</code>是全局变量，则会自动初始化为 0。如果是局部变量，则 <code>scores</code> 中内容是未定数，之后的语句 <code>++scores[grade/10]</code> 会发生未知错误。</p>
<h4 id="section-43">3.34</h4>
<p>程序作用是将 p1 向前移动 p2-p1 个位置；当 p1 + (p2 - p1) 超过数组索引时，为非法访问。</p>
<h4 id="section-44">3.35</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = a; p &lt;a + <span class="number">5</span>; ++p)</span><br><span class="line">        *p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c: a)</span><br><span class="line">        cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-45">3.36</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> abeg = <span class="built_in">begin</span>(a); <span class="keyword">auto</span> aend = <span class="built_in">end</span>(a);</span><br><span class="line">    <span class="keyword">auto</span> bbeg = <span class="built_in">begin</span>(b); <span class="keyword">auto</span> bend = <span class="built_in">end</span>(b);</span><br><span class="line">    <span class="keyword">while</span>(abeg &lt; aend)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*abeg != *bbeg)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ++abeg;</span><br><span class="line">        ++bbeg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(abeg == aend &amp;&amp; bbeg == bend)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;相等&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;不相等&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 vector 更简单，直接判断即可。</span></span><br></pre></td></tr></table></figure>
<h4 id="section-46">3.38</h4>
<p>指针内容表示的是地址，两个指针相加表示两个地址相加，可能会得到非法地址。</p>
<h4 id="section-47">3.41</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(a), end(a))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : a)</span><br><span class="line">        cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-48">3.43</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">3</span>, col = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ai[row][col]=&#123;</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//第一种</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in"><span class="keyword">int</span></span> (&amp;arr)[col] : ai)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;c : arr)</span><br><span class="line">            cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            cout&lt;&lt;ai[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in"><span class="keyword">int</span></span> (*p)[col] = ai; p != ai + row; ++p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> *q = *p; q != *p + col; ++q)&#123;</span><br><span class="line">            cout&lt;&lt;*q&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chapter-4">Chapter 4</h3>
<h4 id="section-49">4.10</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; ivec;</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>( cin&gt;&gt;c )&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">42</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ivec.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(auto c : ivec)</span><br><span class="line">        cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-50">4.17</h4>
<blockquote>
<p>说说前置递增运算符和后置递增运算符的区别。</p>
</blockquote>
<p>前置递增运算符是先递增，再将递增后的值赋值给其他变量，后置递增运算符是递增后，将对象原始值的副本返回</p>
<h4 id="section-51">4.21</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; ivec;</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>( cin&gt;&gt;c )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( c%<span class="number">2</span> != <span class="number">0</span> )</span><br><span class="line">            c = c*<span class="number">2</span>;</span><br><span class="line">        ivec.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (auto c : ivec)</span><br><span class="line">        cout&lt;&lt; c &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-52">4.28</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;char: &quot;</span>&lt;&lt;sizeof(char)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int: &quot;</span>&lt;&lt;sizeof(<span class="built_in">int</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;float: &quot;</span>&lt;&lt;sizeof(<span class="built_in">float</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;double: &quot;</span>&lt;&lt;sizeof(double)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;long: &quot;</span> &lt;&lt;sizeof(long)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;long long: &quot;</span>&lt;&lt;sizeof(long long);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chapter-5">Chapter 5</h3>
<h4 id="section-53">5.5</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> grade;</span><br><span class="line">    <span class="keyword">while</span>( cin&gt;&gt;grade )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( grade &gt; <span class="number">100</span> )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>( grade &lt; <span class="number">60</span> )</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;F&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( grade &lt; <span class="number">70</span> )</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;D&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( grade &lt; <span class="number">80</span> )</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;C&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( grade &lt; <span class="number">90</span> )</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;B&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( grade &lt; <span class="number">100</span> )</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;A&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;A++&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-54">5.9</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> vowel = <span class="number">0</span>;</span><br><span class="line">    char c;</span><br><span class="line">    <span class="keyword">while</span>( cin&gt;&gt;c )&#123;</span><br><span class="line">        <span class="keyword">if</span>((c == <span class="string">&#x27;a&#x27;</span>) | (c == <span class="string">&#x27;A&#x27;</span>) | (c == <span class="string">&#x27;E&#x27;</span>) </span><br><span class="line">         | (c == <span class="string">&#x27;e&#x27;</span>) | (c == <span class="string">&#x27;I&#x27;</span>) | (c == <span class="string">&#x27;i&#x27;</span>) </span><br><span class="line">         | (c == <span class="string">&#x27;O&#x27;</span>) | (c == <span class="string">&#x27;o&#x27;</span>) | (c == <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">         | (c == <span class="string">&#x27;u&#x27;</span>))</span><br><span class="line">             ++vowel;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;vowel;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-55">5.14</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">主要思路是：<span class="built_in">max</span> 记录当前出现的最大连续次数； </span><br><span class="line">count 记录此次出现的最大连续次数；</span><br><span class="line">利用 s1, s2 来判断前后两个字串是否相等。</span><br><span class="line">每次使用 count 和 <span class="built_in">max</span> 比较后，都需要将 count 置 <span class="number">1</span>。</span><br><span class="line">*/</span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    string s1, s2, <span class="built_in">str</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    <span class="keyword">while</span>( cin &gt;&gt; s2 )&#123;</span><br><span class="line">        <span class="keyword">if</span>( s2 == s1)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">            <span class="built_in">str</span> = s1;</span><br><span class="line">            <span class="built_in">max</span> = count;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span> &gt; <span class="number">1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="built_in">str</span>&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;<span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;没有重复的单词出现&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-56">5.17</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; iver1&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; iver2&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">len</span> = iver1.size() &lt; iver2.size() ? iver1.size() : iver2.size();</span><br><span class="line">    <span class="keyword">for</span> (auto i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iver1[i] != iver2[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;假&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;真&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-57">5.19</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input two strings: &quot;</span>;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">if</span>(s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>())</span><br><span class="line">        cout&lt;&lt;s1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-58">5.20</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    cin&gt;&gt;s1;</span><br><span class="line">    <span class="keyword">while</span>( cin&gt;&gt;s2 )&#123;</span><br><span class="line">        <span class="keyword">if</span>( s1 == s2)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s1 = s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        cout&lt;&lt;s1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No words repeat.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-59">5.23-25</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;i&gt;&gt;j)&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不能为零&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;i/j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(runtime_error err)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;err.<span class="built_in">what</span>()&lt;&lt;<span class="string">&quot;\nTry again?(y/n)&quot;</span>;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chapter-6">Chapter 6</h3>
<h4 id="section-60">6.10</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;交换前：&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;交换后：&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-61">6.17</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_include_upper</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">to_lower</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123;</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;XiongLingYu&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">is_include_upper</span>(s)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">to_lower</span>(s);</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-62">6.22</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *(&amp;a), <span class="keyword">int</span> *(&amp;b))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *t;</span><br><span class="line">    t = a, a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> *x = &amp;a, *y = &amp;b;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">swap</span>(x, y);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-63">6.27</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">( initializer_list&lt;<span class="keyword">int</span>&gt; il )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : il)&#123;</span><br><span class="line">        res += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">sum</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">16</span>&#125;);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-64">6.33</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;::iterator begin, vector&lt;<span class="keyword">int</span>&gt;::iterator end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin == end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;*begin;</span><br><span class="line">    <span class="built_in">print</span>(begin+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ivec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">begin</span>(ivec), <span class="built_in">end</span>(ivec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reference">Reference</h3>
<ol type="1">
<li><a href="https://github.com/fsaadatmand/Cpp-Primer">fsaadatmand-cpp</a></li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 添加图片和PDF预览</title>
    <url>/configuration/Hexo-%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E5%92%8CPDF%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<center>
Hexo 中添加图片和PDF预览
</center>
<span id="more"></span>
<h4 id="添加图片">添加图片</h4>
<ol type="1">
<li>首先安装插件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></li>
<li>打开 Hexo 中的配置文件 _config.yml，设置 <code>post_asset_folder</code> 为 true</li>
<li>打开 /node_modules/hexo-asset-image/index.js，将内容替换为以下代码 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"> hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> config = hexo.config;</span><br><span class="line"> <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">         <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">     <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">     <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">     <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">     link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">     <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">         <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">         <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">         <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">         <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">             <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">             <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">             <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">             !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">             <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">             <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">             <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                 srcArray.shift();</span><br><span class="line">             src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">             $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">             <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">             <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     data[key] = $.html();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li>
<li>以上完成后，直接通过例如 <code>hexo new test</code> 创建文件后，会在 source/_posts 下生成 test.md 和 test 文件夹，我们只需要把插入的图片放置在此文件夹中，然后正常使用 markdown 语法添加图片即可。</li>
</ol>
<h4 id="预览pdf">预览PDF</h4>
<ol type="1">
<li>安装插件 hexo-pdf <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure></li>
<li>设置主题的配置文件 _config.yml 中的 pdf enable 为 true。</li>
<li>将资源文件放置在同名文件夹中，使用以下语法实现 PDF 预览。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% pdf ./Attention-Is-All-You-Need.pdf %&#125;</span><br></pre></td></tr></table></figure> <div class="pdfobject-container" data-target="./Redmon_You_Only_Look_CVPR_2016_paper.pdf" data-height="500px"></div></li>
</ol>
]]></content>
      <categories>
        <category>configuration</category>
      </categories>
      <tags>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>classic semantic segmentation paper</title>
    <url>/Semantic-Segmentation/classic-semantic-segmentation-paper/</url>
    <content><![CDATA[<center>
经典语义分割论文
</center>
<span id="more"></span>
<h5 id="cvpr-2015fcn">1. CVPR 2015，FCN</h5>
<p>深度学习语义分割开山之作</p>
<p>论文名称：Fully convolutional networks for semantic segmentation</p>
<p><strong>摘要：</strong></p>
<p>卷积网络在特征分层领域是非常强大的视觉模型。我们证明了经过端到端、像素到像素训练的卷积网络超过语义分割中最先进的技术。我们的核心观点是建立“全卷积”网络，输入任意尺寸，经过有效的推理和学习产生相应尺寸的输出。我们定义并指定全卷积网络的空间，解释它们在空间范围内dense prediction任务(预测每个像素所属的类别)和获取与先验模型联系的应用。我们改编当前的分类网络(AlexNet [22] ,the VGG net [34] , and GoogLeNet [35] )到完全卷积网络和通过微调 [5]传递它们的学习表现到分割任务中。然后我们定义了一个跳跃式的架构，结合来自深、粗层的语义信息和来自浅、细层的表征信息来产生准确和精细的分割。我们的完全卷积网络成为了在PASCAL VOC最出色的分割方式（在2012年相对62.2%的平均IU提高了20%），NYUDv2，和SIFT Flow,对一个典型图像推理只需要花费不到0.2秒的时间。</p>
<p>论文链接：https://arxiv.org/pdf/1411.4038.pd</p>
<p>源码：https://github.com/shelhamer/fcn.berkeleyvision.org</p>
<h5 id="micca-2015u-net">2. MICCA 2015，U-Net</h5>
<p>医学图像分割领头者</p>
<p>论文名称：U-Net: Convolutional Networks for Biomedical Image Segmentation</p>
<p><strong>摘要：</strong></p>
<p>网络结构包括一个捕获上下文信息的收缩路径和一个用于精确定位的对称扩张路径，该网络能使用很少的图像就能够进行端到端的训练，并且在ISBI对电子显微镜下神经元结构进行的分割挑战方面胜过先前的最佳方法（滑动窗口卷积网络）。</p>
<p>论文链接：https://arxiv.org/pdf/1505.04597v1.pdf</p>
<p>包含经过训练的网络、源代码等：</p>
<p>https://lmb.informatik.uni-freiburg.de/people/ronneber/u-net/u-net-release-2015-10-02.tar.gz</p>
<h5 id="iclr-2018">3 ICLR 2018</h5>
<p>论文名称：FusionNet: A deep fully residual convolutional neural network for image segmentation in connectomics</p>
<p><strong>摘要：</strong></p>
<p>Electron microscopic connectomics（电子显微镜连接组学）是一个炙手可热的研究方向，致力于通过高通量、纳米级显微镜来综合理解脑部连接图。但是人工消耗很大，现在深度学习网络发展的如日中天，我们搭建了一个FusionNet网络，用于在连接组学数据中自动分割神经元结构。（用神经网络去研究神经网络）FusionNet利用了机器学习的最新进展，如语义分割和残差网络，并引入了允许更深的网络架构来实现更准确的分割的基于累加的跳过连接。我们与ISBI EM segmentation challenge（这是一个挑战赛，EM指电子显微镜）的前几名的结果进行了对比，展现了我们的网络的性能。我们还展示了两个不同任务的分割结果，包括细胞膜和细胞核分割以及细胞形态的统计分析。</p>
<p>论文链接：https://arxiv.org/ftp/arxiv/papers/1612/1612.05360.pdf</p>
<h5 id="cvpr2015segnet">4. CVPR2015，SegNet</h5>
<p>语义分割必读算法，和DeconvNet 类似。</p>
<p>论文名称：Segnet: A deep convolutional encoder-decoder architecture for image segmentation</p>
<p><strong>摘要：</strong></p>
<p>SegNet 有三个部分构成：一个 encoder network，一个对应的 decoder network，最后一个像素级别的分类层。本文最大的亮点在：在 encoder 阶段我们做 max-pooling时，我们将 pooling indices 记录下来，在decoder upsamples 使用这些 pooling indices 得到稀疏的 upsampled maps，再用 trainable filters 进行卷积得到 dense feature maps。</p>
<p>论文链接：https://arxiv.org/pdf/1511.00561.pdf</p>
<h5 id="iccv-2015deconvnet">5 ICCV 2015，DeconvNet</h5>
<p>论文名称：Learning deconvolution network for semantic segmentation</p>
<p><strong>摘要：</strong></p>
<ol type="1">
<li><p>提出新的语义分割算法：深度反卷积网络；</p></li>
<li><p>在VGG-16卷积层上学习网络；</p></li>
<li><p>反卷积组成：deconvolution and unpooling layers，识别逐像素的类别标签，并预测分割mask；</p></li>
<li><p>将object proposal（edge box）送入训练后的网络，然后整幅图像是这些proposal的分割结果的组合,这样就可以解决物体太大或者太小所带来的分割问题；</p></li>
<li><p>deep deconvolution network 和候选区域级别的预测(proposal-wise predictio)，改进了现存的基于FCN的方法．</p></li>
<li><p>我们的算法能识别精细的结构以及不同尺度大小的目标</p></li>
</ol>
<p>论文链接：https://arxiv.org/pdf/1505.04366.pdf</p>
<h5 id="iclr-2015deeplabv1">6. ICLR 2015，DeepLabv1</h5>
<p>带孔卷积，大有作为</p>
<p>论文名称：DeepLab V1: Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFs</p>
<p><strong>摘要：</strong></p>
<p>CRF简单来说，能做到的就是在决定一个位置的像素值时（在这个paper里是label），会考虑周围邻居的像素值（label），这样能抹除一些噪音。但是通过CNN得到的feature map在一定程度上已经足够平滑了，所以short range的CRF没什么意义。于是作者采用了fully connected CRF，这样考虑的就是全局的信息了。</p>
<p>论文链接：https://arxiv.org/pdf/1412.7062.pdf</p>
<h5 id="tpami-2017-deeplabv2">7. TPAMI 2017 DeepLabv2</h5>
<p>论文名称：V2: Semantic Image Segmentation with Deep Convolutional Nets, Atrous Convolution, and Fully Connected CRFs</p>
<p><strong>摘要：</strong></p>
<p>提出并强调洞卷积（atrous convolution）的作用与实际应用操作，Atrous convolution可以精确地控制在深度卷积神经网络中计算特征响应的分辨率，它还允许在不增加参数数量或计算量的情况下，有效地扩大过滤器的视野，以结合更多的上下文信息。</p>
<p>论文链接：https://export.arxiv.org/pdf/1606.00915</p>
<h5 id="eccv-2018-deeplabv3">8. ECCV 2018 DeepLabv3</h5>
<p>论文名称：V3: Rethinking Atrous Convolution for Semantic Image Segmentation</p>
<p><strong>摘要：</strong></p>
<p>DeepLabv3进一步探讨空洞卷积，这是一个在语义分割任务中：可以调整滤波器视野、控制卷积神经网络计算的特征响应分辨率的强大工具。为了解决多尺度下的目标分割问题，我们设计了空洞卷积级联或不同采样率空洞卷积并行架构。此外，我们强调了ASPP(Atrous Spatial Pyramid Pooling)模块，该模块可以在获取多个尺度上卷积特征，进一步提升性能。同时，我们分享了实施细节和训练方法，此次提出的DeepLabv3相比先前的版本有显著的效果提升，在PASCAL VOC 2012上获得了先进的性能。</p>
<p>论文链接：https://arxiv.org/pdf/1706.05587.pdf</p>
<h5 id="eccv-2018-deeplabv4">9. ECCV 2018 DeepLabv4</h5>
<p>论文名称：V4: Encoder-Decoder with Atrous Separable Convolution for Semantic Image Segmentation</p>
<p><strong>摘要：</strong></p>
<p>空间金字塔池模块或编码 - 解码器结构用于深度神经网络中解决语义分割任务。前一种网络能够通过利用多个速率和多个有效视场的过滤器或池化操作探测输入特征来编码多尺度上下文信息，而后一种网络可以通过逐渐恢复空间信息来捕获更清晰的对象边界。在这项工作中，我们建议结合两种方法的优点。具体来说，我们提出的模型DeepLabv3 +通过添加一个简单而有效的解码器模块来扩展DeepLabv3，以优化分割结果，尤其是沿着对象边界。我们进一步探索Xception模型并将深度可分离卷积应用于Atrous Spatial Pyramid Pooling和解码器模块，从而产生更快更强的编码器-解码器网络。我们证明了所提出的模型在PASCAL VOC 2012语义图像分割数据集上的有效性，并且在没有任何后处理的情况下在测试集上实现了89％的性能。我们的论文附有Tensorflow中提出的模型的公开参考实现。</p>
<p>论文链接：https://arxiv.org/pdf/1802.02611.pdf</p>
<h5 id="cvpr-2017gcn">10. CVPR 2017，GCN</h5>
<p>开拓语义分割新思想</p>
<p>论文名称：Large Kernel Matters--Improve Semantic Segmentation by Global Convolutional Network</p>
<p><strong>摘要：</strong></p>
<p>文章认为，classification和localization之间是有冲突的，我们平时所用的卷积分割网络，在提高分割效果的同时，削弱了分类的能力。文中认为通过设置大的感受野可以获得featuremap与pixel score之间的densely connections。</p>
<p>论文链接：https://arxiv.org/pdf/1703.02719.pdf</p>
<h5 id="eccv-2018exfuse">11. ECCV 2018，ExFuse</h5>
<p>宏观角度看待语义分割</p>
<p>论文名称：ExFuse: Enhancing Feature Fusion for Semantic Segmentation</p>
<p><strong>摘要：</strong></p>
<p>文中提到说目前语义分割的框架，大多是FCN的框架，使用encode得到将语义信息融合到feature map中，然后再使用decode通过feature map得到分割结果，一般来说encoder都是使用pre-trained的分割网络进行transfer过来的，但是呢，虽然这样encoder可以得到更丰富的语义信息，但是损失了分辨率，对于恢复到原本分辨率分割图来说带来了困难，因此U-net被提出来解决这个问题，使用skip connection将hight-level low-resolution from top layers和low-level high-resolution from bottom layers的特征融合起来。</p>
<p>论文链接：https://arxiv.org/pdf/1804.03821.pdf</p>
<h5 id="cvpr-2018">12. CVPR 2018</h5>
<p>论文名称：Learning a discriminative feature network for semantic segmentation</p>
<p><strong>摘要：</strong></p>
<p>创新点就是特征区分网络discriminative feature network，本别叫做平滑网络Smooth Network以及边界网络Border Network。这两个网络可以处理类内一致性以及类间区分性。最终。形成了encoder-decoder网络结构，美其名曰Discriminative Feature Network</p>
<p>论文链接： https://arxiv.org/pdf/1804.09337.pdf</p>
<blockquote>
<p>文章转自 <a href="https://www.bilibili.com/read/cv13752355?spm_id_from=444.41.0.0">B站深度之眼</a>，如有侵权，请联系删除。</p>
</blockquote>
]]></content>
      <categories>
        <category>Semantic Segmentation</category>
      </categories>
      <tags>
        <tag>Semantic Segmentation</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLO V5-4.0源码解读</title>
    <url>/YOLO-V5/YOLO-V5-4-0%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<center>
YOLO v5-4.0 版本源码解读
</center>
<span id="more"></span>
<p>目前yolov5已经更新迭代了多个版本，最新版本已经到了<a href="https://github.com/ultralytics/yolov5/tree/v6.0">YOLOv5-6.0</a>，并且处于一直维护状态。本博客主要是对<a href="https://github.com/ultralytics/yolov5/tree/v4.0">YOLOv5-4.0</a>的项目代码文件做解读。</p>
<h4 id="项目结构">项目结构</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yolov5-<span class="number">4.0</span></span><br><span class="line">├─ data</span><br><span class="line">│  ├─ images               <span class="comment"># 存放待处理图片</span></span><br><span class="line">│  ├─ coco.yaml            <span class="comment"># coco数据集配置文件</span></span><br><span class="line">│  ├─ coco128.yaml         <span class="comment"># coco128数据集配置文件</span></span><br><span class="line">│  ├─ hyp.finetune.yaml    <span class="comment"># 模型微调超参数配置文件</span></span><br><span class="line">│  ├─ hyp.scratch.yaml     <span class="comment"># 模型从头训练超参数配置文件</span></span><br><span class="line">│  └─ voc.yaml             <span class="comment"># voc数据集配置文件</span></span><br><span class="line">├─ models</span><br><span class="line">│  ├─ common.py            <span class="comment"># 模型组件定义代码</span></span><br><span class="line">│  ├─ experimental.py      <span class="comment"># 实验性质代码</span></span><br><span class="line">│  ├─ export.py            <span class="comment"># 模型导出脚本</span></span><br><span class="line">│  ├─ hub</span><br><span class="line">│  ├─ yolo.py              <span class="comment"># Detect 以及 Model 构建</span></span><br><span class="line">│  ├─ yolov5l.yaml         <span class="comment"># yolov5l 模型配置文件</span></span><br><span class="line">│  ├─ yolov5m.yaml         <span class="comment"># yolov5m 模型配置文件</span></span><br><span class="line">│  ├─ yolov5s.yaml         <span class="comment"># yolov5s 模型配置文件</span></span><br><span class="line">│  ├─ yolov5x.yaml         <span class="comment"># yolov5x 模型配置文件</span></span><br><span class="line">│  └─ __init__.py</span><br><span class="line">├─ runs</span><br><span class="line">│  ├─ detect               <span class="comment"># 输出推断结果</span></span><br><span class="line">│  ├─ test                 <span class="comment"># 测试结果</span></span><br><span class="line">│  └─ train                <span class="comment"># 训练结果</span></span><br><span class="line">├─ detect.py               <span class="comment"># 前向推理代码</span></span><br><span class="line">├─ test.py                 <span class="comment"># 测试模型代码</span></span><br><span class="line">├─ train.py                <span class="comment"># 训练网络代码</span></span><br><span class="line">├─ tutorial.ipynb          <span class="comment"># 例程</span></span><br><span class="line">├─ requirements.txt        <span class="comment"># 环境所需的安装包</span></span><br><span class="line">├─ hubconf.py</span><br><span class="line">├─ LICENSE</span><br><span class="line">├─ Dockerfile</span><br><span class="line">├─ utils</span><br><span class="line">│  ├─ activations.py       <span class="comment"># 激活函数</span></span><br><span class="line">│  ├─ autoanchor.py        <span class="comment"># 自动计算锚框</span></span><br><span class="line">│  ├─ datasets.py          <span class="comment"># 定义数据集类并加载数据集</span></span><br><span class="line">│  ├─ general.py           <span class="comment"># 项目通用函数代码</span></span><br><span class="line">│  ├─ google_app_engine</span><br><span class="line">│  │  ├─ additional_requirements.txt</span><br><span class="line">│  │  ├─ app.yaml</span><br><span class="line">│  │  └─ Dockerfile</span><br><span class="line">│  ├─ google_utils.py      <span class="comment"># 谷歌云使用相关代码</span></span><br><span class="line">│  ├─ loss.py              <span class="comment"># 损失函数代码</span></span><br><span class="line">│  ├─ metrics.py           <span class="comment"># 模型验证衡量指标</span></span><br><span class="line">│  ├─ plots.py             <span class="comment"># 画图代码</span></span><br><span class="line">│  ├─ torch_utils.py       <span class="comment"># 辅助程序代码</span></span><br><span class="line">│  └─ __init__.py</span><br><span class="line">└─ weights</span><br><span class="line">   ├─ download_weights.sh</span><br><span class="line">   ├─ yolov5m.pt           <span class="comment"># yolov5m 模型权重文件</span></span><br><span class="line">   └─ yolov5s.pt           <span class="comment"># yolov5s 模型权重文件</span></span><br></pre></td></tr></table></figure>
<h4 id="detect.py">detect.py</h4>
<p><code>detect.py</code> 用于前向推断，可支持多种流输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># detect.py 源码解读</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># from numpy.core.fromnumeric import shape</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> models.experimental <span class="keyword">import</span> attempt_load</span><br><span class="line"><span class="keyword">from</span> utils.datasets <span class="keyword">import</span> LoadStreams, LoadImages</span><br><span class="line"><span class="keyword">from</span> utils.general <span class="keyword">import</span> check_img_size, non_max_suppression, apply_classifier, scale_coords, xyxy2xywh, \</span><br><span class="line">    strip_optimizer, set_logging, increment_path</span><br><span class="line"><span class="keyword">from</span> utils.plots <span class="keyword">import</span> plot_one_box</span><br><span class="line"><span class="keyword">from</span> utils.torch_utils <span class="keyword">import</span> select_device, load_classifier, time_synchronized</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">整个网络检测流程：</span></span><br><span class="line"><span class="string">1. 创建保存输出文件的文件夹</span></span><br><span class="line"><span class="string">2. 加载模型文件，并做一些检查确保图片尺寸符合网络模型需求</span></span><br><span class="line"><span class="string">3. 根据输入源进行不同的数据加载方式</span></span><br><span class="line"><span class="string">4. 迭代数据集进行模型前向推断</span></span><br><span class="line"><span class="string">   - 非极大值抑制</span></span><br><span class="line"><span class="string">   - 为输出路径添加图片名称</span></span><br><span class="line"><span class="string">   - 调整预测框(resize + padding --&gt; 原图片坐标)</span></span><br><span class="line"><span class="string">   - 原图上画框和标签置信度、以及保存坐标框位置</span></span><br><span class="line"><span class="string">   - 保存图片、以及坐标框文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect</span>(<span class="params">save_img=<span class="literal">True</span></span>):</span></span><br><span class="line">    source, weights, view_img, save_txt, imgsz = opt.source, opt.weights, opt.view_img, opt.save_txt, opt.img_size</span><br><span class="line">    webcam = source.isnumeric() <span class="keyword">or</span> source.endswith(<span class="string">&#x27;.txt&#x27;</span>) <span class="keyword">or</span> source.lower().startswith(</span><br><span class="line">        (<span class="string">&#x27;rtsp://&#x27;</span>, <span class="string">&#x27;rtmp://&#x27;</span>, <span class="string">&#x27;http://&#x27;</span>)) <span class="comment"># 是否使用摄像头或网址视频等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Directories 设置图片保存路径</span></span><br><span class="line">    save_dir = Path(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))  <span class="comment"># increment run</span></span><br><span class="line">    <span class="comment"># make dir 创建文件夹</span></span><br><span class="line">    (save_dir / <span class="string">&#x27;labels&#x27;</span> <span class="keyword">if</span> save_txt <span class="keyword">else</span> save_dir).mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize</span></span><br><span class="line">    set_logging() <span class="comment"># 初始化日志文件</span></span><br><span class="line">    device = select_device(opt.device) <span class="comment"># 选择训练的设备 cpu, cuda</span></span><br><span class="line">    half = device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span>  <span class="comment"># half precision only supported on CUDA 如设备为cpu, 则不能使用半精度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load model 加载模型</span></span><br><span class="line">    model = attempt_load(weights, map_location=device)  <span class="comment"># load FP32 model</span></span><br><span class="line">    imgsz = check_img_size(imgsz, s=model.stride.<span class="built_in">max</span>())  <span class="comment"># check img_size 确保图片能整除 32 （如果不能则调整为能整除并输出）</span></span><br><span class="line">    <span class="keyword">if</span> half:</span><br><span class="line">        model.half()  <span class="comment"># to FP16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Second-stage classifier 设置第二层分类器，默认不使用</span></span><br><span class="line">    classify = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> classify:</span><br><span class="line">        modelc = load_classifier(name=<span class="string">&#x27;resnet101&#x27;</span>, n=<span class="number">2</span>)  <span class="comment"># initialize 初始化模型</span></span><br><span class="line">        modelc.load_state_dict(torch.load(<span class="string">&#x27;weights/resnet101.pt&#x27;</span>, map_location=device)[<span class="string">&#x27;model&#x27;</span>]).to(device).<span class="built_in">eval</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 用来判断是否是另一个新视频</span></span><br><span class="line">    vid_path, vid_writer = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="comment"># Set Dataloader 根据不同的输入源来设置不同的数据加载方式</span></span><br><span class="line">    <span class="keyword">if</span> webcam:</span><br><span class="line">        view_img = <span class="literal">True</span></span><br><span class="line">        cudnn.benchmark = <span class="literal">True</span>  <span class="comment"># set True to speed up constant image size inference</span></span><br><span class="line">        dataset = LoadStreams(source, img_size=imgsz) <span class="comment"># 加载摄像头视频流</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        save_img = <span class="literal">True</span></span><br><span class="line">        dataset = LoadImages(source, img_size=imgsz) <span class="comment"># 加载图像或视频</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get names and colors</span></span><br><span class="line">    <span class="comment"># 获得数据集标签名称 以及为每一类设置一种颜色</span></span><br><span class="line">    names = model.module.names <span class="keyword">if</span> <span class="built_in">hasattr</span>(model, <span class="string">&#x27;module&#x27;</span>) <span class="keyword">else</span> model.names</span><br><span class="line">    colors = [[random.randint(<span class="number">0</span>, <span class="number">255</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run inference</span></span><br><span class="line">    img = torch.zeros((<span class="number">1</span>, <span class="number">3</span>, imgsz, imgsz), device=device)  <span class="comment"># init img</span></span><br><span class="line">    _ = model(img.half() <span class="keyword">if</span> half <span class="keyword">else</span> img) <span class="keyword">if</span> device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span> <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># run once 试运行一次，判断模型是否正常</span></span><br><span class="line">    <span class="comment"># 开始迭代</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    path：图片路径</span></span><br><span class="line"><span class="string">    img：进行 resize 和 pad 之后的图片 (c, h, w) </span></span><br><span class="line"><span class="string">    img0s：原图片</span></span><br><span class="line"><span class="string">    vid_cap：判断是否是视频流</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> path, img, im0s, vid_cap <span class="keyword">in</span> dataset:</span><br><span class="line">        img = torch.from_numpy(img).to(device)</span><br><span class="line">        img = img.half() <span class="keyword">if</span> half <span class="keyword">else</span> img.<span class="built_in">float</span>()  <span class="comment"># uint8 to fp16/32</span></span><br><span class="line">        img /= <span class="number">255.0</span>  <span class="comment"># 0 - 255 to 0.0 - 1.0</span></span><br><span class="line">        <span class="keyword">if</span> img.ndimension() == <span class="number">3</span>: <span class="comment"># 如果没有 batch_size or batch_size=1，在最前面添加一个轴</span></span><br><span class="line">            img = img.unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inference</span></span><br><span class="line"><span class="string">        框数量：(h/32 * w/32 + h/16 * w/16 + h/8 * w/8) * 3</span></span><br><span class="line"><span class="string">        pred 为模型输出结果（预测框）</span></span><br><span class="line"><span class="string">        pred[:,0:4]为预测框坐标</span></span><br><span class="line"><span class="string">        pred[:,4] 为 objectiveness 置信度</span></span><br><span class="line"><span class="string">        pred[:,5:-1] 为分类概率结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        t1 = time_synchronized()</span><br><span class="line">        pred = model(img, augment=opt.augment)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Apply NMS</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        pred</span></span><br><span class="line"><span class="string">        conf_thres</span></span><br><span class="line"><span class="string">        iou_thres</span></span><br><span class="line"><span class="string">        classes 是否保留特定类别</span></span><br><span class="line"><span class="string">        agnostic_nms 进行 nms 是否去除不同类别的框</span></span><br><span class="line"><span class="string">        max_det 最大的预测框数量</span></span><br><span class="line"><span class="string">        经过 nms 后 xywh -&gt; xyxy</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pred = non_max_suppression(pred, opt.conf_thres, opt.iou_thres, classes=opt.classes, agnostic=opt.agnostic_nms)</span><br><span class="line">        t2 = time_synchronized() <span class="comment"># 使用时间同步记录当前时间(可能多个 GPU)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Apply Classifier 做二级分类</span></span><br><span class="line">        <span class="keyword">if</span> classify:</span><br><span class="line">            pred = apply_classifier(pred, modelc, img, im0s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process detections</span></span><br><span class="line">        <span class="keyword">for</span> i, det <span class="keyword">in</span> <span class="built_in">enumerate</span>(pred):  <span class="comment"># detections per image (实际上每次只有一张图片)</span></span><br><span class="line">            <span class="keyword">if</span> webcam:  <span class="comment"># batch_size &gt;= 1</span></span><br><span class="line">                p, s, im0, frame = path[i], <span class="string">&#x27;%g: &#x27;</span> % i, im0s[i].copy(), dataset.count</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p, s, im0, frame = path, <span class="string">&#x27;&#x27;</span>, im0s, <span class="built_in">getattr</span>(dataset, <span class="string">&#x27;frame&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># p 是原图片路径</span></span><br><span class="line">            p = Path(p)  <span class="comment"># to Path</span></span><br><span class="line">            <span class="comment"># 设置保存图片或视频的路径</span></span><br><span class="line">            save_path = <span class="built_in">str</span>(save_dir / p.name)  <span class="comment"># img.jpg</span></span><br><span class="line">            <span class="comment"># 设置保存预测框坐标 .txt的路径</span></span><br><span class="line">            txt_path = <span class="built_in">str</span>(save_dir / <span class="string">&#x27;labels&#x27;</span> / p.stem) + (<span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> dataset.mode == <span class="string">&#x27;image&#x27;</span> <span class="keyword">else</span> <span class="string">f&#x27;_<span class="subst">&#123;frame&#125;</span>&#x27;</span>)  <span class="comment"># img.txt</span></span><br><span class="line">            <span class="comment"># 设置打印信息</span></span><br><span class="line">            s += <span class="string">&#x27;%gx%g &#x27;</span> % img.shape[<span class="number">2</span>:]  <span class="comment"># print string</span></span><br><span class="line">            gn = torch.tensor(im0.shape)[[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]  <span class="comment"># normalization gain whwh 用于四个坐标 xyxy 的归一化</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(det):</span><br><span class="line">                <span class="comment"># Rescale boxes from img_size to im0 size</span></span><br><span class="line">                <span class="comment"># 调整预测框的坐标：基于 resize + pad 图片的坐标 --&gt; 基于原 size 图片的坐标</span></span><br><span class="line">                det[:, :<span class="number">4</span>] = scale_coords(img.shape[<span class="number">2</span>:], det[:, :<span class="number">4</span>], im0.shape).<span class="built_in">round</span>()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Print results 统计并记录检测到的每类的数量</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> det[:, -<span class="number">1</span>].unique():</span><br><span class="line">                    n = (det[:, -<span class="number">1</span>] == c).<span class="built_in">sum</span>()  <span class="comment"># detections per class</span></span><br><span class="line">                    s += <span class="string">f&#x27;<span class="subst">&#123;n&#125;</span> <span class="subst">&#123;names[<span class="built_in">int</span>(c)]&#125;</span>s, &#x27;</span>  <span class="comment"># add to string</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Write results</span></span><br><span class="line">                <span class="comment"># 保存预测结果，依次保存每一个输出框，以及画出每一个输出框。</span></span><br><span class="line">                <span class="keyword">for</span> *xyxy, conf, cls <span class="keyword">in</span> <span class="built_in">reversed</span>(det):</span><br><span class="line">                    <span class="keyword">if</span> save_txt:  <span class="comment"># Write to file</span></span><br><span class="line">                        <span class="comment"># 先 xyxy --&gt; xywh，再归一化、转化为 list 再保存</span></span><br><span class="line">                        xywh = (xyxy2xywh(torch.tensor(xyxy).view(<span class="number">1</span>, <span class="number">4</span>)) / gn).view(-<span class="number">1</span>).tolist()  <span class="comment"># normalized xywh</span></span><br><span class="line">                        line = (cls, *xywh, conf) <span class="keyword">if</span> opt.save_conf <span class="keyword">else</span> (cls, *xywh)  <span class="comment"># label format</span></span><br><span class="line">                        <span class="keyword">with</span> <span class="built_in">open</span>(txt_path + <span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                            f.write((<span class="string">&#x27;%g &#x27;</span> * <span class="built_in">len</span>(line)).rstrip() % line + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="comment"># 在原图上画框</span></span><br><span class="line">                    <span class="keyword">if</span> save_img <span class="keyword">or</span> view_img:  <span class="comment"># Add bbox to image</span></span><br><span class="line">                        label = <span class="string">f&#x27;<span class="subst">&#123;names[<span class="built_in">int</span>(cls)]&#125;</span> <span class="subst">&#123;conf:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line">                        <span class="comment"># 直接在原图画框</span></span><br><span class="line">                        plot_one_box(xyxy, im0, label=label, color=colors[<span class="built_in">int</span>(cls)], line_thickness=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Print time (inference + NMS) # 输出一张图片推断时间</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;s&#125;</span>Done. (<span class="subst">&#123;t2 - t1:<span class="number">.3</span>f&#125;</span>s)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Stream results 设置展示</span></span><br><span class="line">            <span class="keyword">if</span> view_img:</span><br><span class="line">                cv2.imshow(<span class="built_in">str</span>(p), im0)</span><br><span class="line">                cv2.waitKey(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Save results (image with detections) 保存图片</span></span><br><span class="line">            <span class="keyword">if</span> save_img:</span><br><span class="line">                <span class="keyword">if</span> dataset.mode == <span class="string">&#x27;image&#x27;</span>:</span><br><span class="line">                    cv2.imwrite(save_path, im0)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># &#x27;video&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> vid_path != save_path:  <span class="comment"># 判断是不是另一个新的视频</span></span><br><span class="line">                        vid_path = save_path</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">isinstance</span>(vid_writer, cv2.VideoWriter):</span><br><span class="line">                            vid_writer.release()  <span class="comment"># release previous video writer</span></span><br><span class="line">                        <span class="keyword">if</span> vid_cap: <span class="comment"># video</span></span><br><span class="line">                            fps = vid_cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">                            w = <span class="built_in">int</span>(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">                            h = <span class="built_in">int</span>(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">                        <span class="keyword">else</span>: <span class="comment"># stream</span></span><br><span class="line">                            fps, w, h = <span class="number">30</span>, im0.shape[<span class="number">1</span>], im0.shape[<span class="number">2</span>]</span><br><span class="line">                            save_path += <span class="string">&#x27;.mp4&#x27;</span></span><br><span class="line">                        fourcc = <span class="string">&#x27;mp4v&#x27;</span>  <span class="comment"># output video codec</span></span><br><span class="line">                        vid_writer = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*fourcc), fps, (w, h))</span><br><span class="line">                    vid_writer.write(im0)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> save_txt <span class="keyword">or</span> save_img:</span><br><span class="line">        s = <span class="string">f&quot;\n<span class="subst">&#123;<span class="built_in">len</span>(<span class="built_in">list</span>(save_dir.glob(<span class="string">&#x27;labels/*.txt&#x27;</span>)))&#125;</span> labels saved to <span class="subst">&#123;save_dir / <span class="string">&#x27;labels&#x27;</span>&#125;</span>&quot;</span> <span class="keyword">if</span> save_txt <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Results saved to <span class="subst">&#123;save_dir&#125;</span><span class="subst">&#123;s&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 打印总时间</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Done. (<span class="subst">&#123;time.time() - t0:<span class="number">.3</span>f&#125;</span>s)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--weights&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;weights/yolov5s.pt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;model.pt path(s)&#x27;</span>) <span class="comment"># 模型权重文件</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--source&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;data/coco128/images/train2017&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;source&#x27;</span>)  <span class="comment"># file/folder, 0 for webcam # 数据源路径，0 则是使用摄像头</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--img-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">640</span>, <span class="built_in">help</span>=<span class="string">&#x27;inference size (pixels)&#x27;</span>) <span class="comment"># 输入模型的图片尺寸格式</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--conf-thres&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.25</span>, <span class="built_in">help</span>=<span class="string">&#x27;object confidence threshold&#x27;</span>) <span class="comment"># 置信度阈值</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--iou-thres&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.45</span>, <span class="built_in">help</span>=<span class="string">&#x27;IOU threshold for NMS&#x27;</span>) <span class="comment"># IoU 阈值</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--device&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;cuda device, i.e. 0 or 0,1,2,3 or cpu&#x27;</span>) <span class="comment"># 使用设备 </span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--view-img&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;display results&#x27;</span>) <span class="comment"># 检测时是否展示图片</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-txt&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save results to *.txt&#x27;</span>) <span class="comment"># 保存预测框数据</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-conf&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save confidences in --save-txt labels&#x27;</span>) <span class="comment"># 保留置信度</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--classes&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;filter by class: --class 0, or --class 0 2 3&#x27;</span>) <span class="comment"># 只检测哪几类</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--agnostic-nms&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;class-agnostic NMS&#x27;</span>) <span class="comment"># 进行 nms 是否去除不同类别的框</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--augment&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;augmented inference&#x27;</span>) <span class="comment"># 前向推断使用图像增广</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--update&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;update all models&#x27;</span>) <span class="comment"># </span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--project&#x27;</span>, default=<span class="string">&#x27;runs/detect&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save results to project/name&#x27;</span>) <span class="comment"># 预测结果输出文件目录</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--name&#x27;</span>, default=<span class="string">&#x27;exp&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save results to project/name&#x27;</span>) <span class="comment"># 文件夹名称</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--exist-ok&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;existing project/name ok, do not increment&#x27;</span>) <span class="comment"># 直接在已经存在的文件夹添加，不新建文件夹</span></span><br><span class="line">    opt = parser.parse_args()</span><br><span class="line">    <span class="built_in">print</span>(opt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">if</span> opt.update:  <span class="comment"># update all models (to fix SourceChangeWarning)</span></span><br><span class="line">            <span class="keyword">for</span> opt.weights <span class="keyword">in</span> [<span class="string">&#x27;yolov5s.pt&#x27;</span>, <span class="string">&#x27;yolov5m.pt&#x27;</span>, <span class="string">&#x27;yolov5l.pt&#x27;</span>, <span class="string">&#x27;yolov5x.pt&#x27;</span>]:</span><br><span class="line">                detect()</span><br><span class="line">                strip_optimizer(opt.weights)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            detect()</span><br></pre></td></tr></table></figure>
<h4 id="test.py">test.py</h4>
<p><code>test.py</code> 用于验证模型训练的效果 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py 源码解读</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> models.experimental <span class="keyword">import</span> attempt_load</span><br><span class="line"><span class="keyword">from</span> utils.datasets <span class="keyword">import</span> create_dataloader</span><br><span class="line"><span class="keyword">from</span> utils.general <span class="keyword">import</span> coco80_to_coco91_class, check_dataset, check_file, check_img_size, box_iou, \</span><br><span class="line">    non_max_suppression, scale_coords, xyxy2xywh, xywh2xyxy, set_logging, increment_path</span><br><span class="line"><span class="keyword">from</span> utils.loss <span class="keyword">import</span> compute_loss</span><br><span class="line"><span class="keyword">from</span> utils.metrics <span class="keyword">import</span> ap_per_class, ConfusionMatrix</span><br><span class="line"><span class="keyword">from</span> utils.plots <span class="keyword">import</span> plot_images, output_to_target, plot_study_txt</span><br><span class="line"><span class="keyword">from</span> utils.torch_utils <span class="keyword">import</span> select_device, time_synchronized</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">测试模型分数流程：</span></span><br><span class="line"><span class="string">1. 检查数据集路径是否正确</span></span><br><span class="line"><span class="string">2. 加载模型（训练阶段则不需要）</span></span><br><span class="line"><span class="string">2. 加载数据集（训练模式不用加载数据集）</span></span><br><span class="line"><span class="string">3. 批量测试图片：</span></span><br><span class="line"><span class="string">    - 前向推断</span></span><br><span class="line"><span class="string">    - 非极大值抑制</span></span><br><span class="line"><span class="string">    - 保存输出结果 txt</span></span><br><span class="line"><span class="string">    - 保留 iou 状态信息</span></span><br><span class="line"><span class="string">    - 画出前三个 batch 图片</span></span><br><span class="line"><span class="string">4. 计算 mAP 等信息，保存信息。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">data,</span></span></span><br><span class="line"><span class="params"><span class="function">         weights=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         batch_size=<span class="number">32</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         imgsz=<span class="number">640</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         conf_thres=<span class="number">0.001</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         iou_thres=<span class="number">0.6</span>,  <span class="comment"># for NMS</span></span></span></span><br><span class="line"><span class="params"><span class="function">         save_json=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         single_cls=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         augment=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         verbose=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         model=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         dataloader=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         save_dir=Path(<span class="params"><span class="string">&#x27;&#x27;</span></span>),  <span class="comment"># for saving images</span></span></span></span><br><span class="line"><span class="params"><span class="function">         save_txt=<span class="literal">False</span>,  <span class="comment"># for auto-labelling</span></span></span></span><br><span class="line"><span class="params"><span class="function">         save_hybrid=<span class="literal">False</span>,  <span class="comment"># for hybrid auto-labelling</span></span></span></span><br><span class="line"><span class="params"><span class="function">         save_conf=<span class="literal">False</span>,  <span class="comment"># save auto-label confidences</span></span></span></span><br><span class="line"><span class="params"><span class="function">         plots=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         log_imgs=<span class="number">0</span></span>):</span>  <span class="comment"># number of logged images</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize/load model and set device</span></span><br><span class="line">    training = model <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 判断是否是在训练阶段使用</span></span><br><span class="line">    <span class="keyword">if</span> training:  <span class="comment"># called by train.py</span></span><br><span class="line">        device = <span class="built_in">next</span>(model.parameters()).device  <span class="comment"># get model device</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># called directly</span></span><br><span class="line">        set_logging()</span><br><span class="line">        device = select_device(opt.device, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Directories</span></span><br><span class="line">        save_dir = Path(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))  <span class="comment"># increment run</span></span><br><span class="line">        (save_dir / <span class="string">&#x27;labels&#x27;</span> <span class="keyword">if</span> save_txt <span class="keyword">else</span> save_dir).mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)  <span class="comment"># make dir</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load model</span></span><br><span class="line">        model = attempt_load(weights, map_location=device)  <span class="comment"># load FP32 model</span></span><br><span class="line">        imgsz = check_img_size(imgsz, s=model.stride.<span class="built_in">max</span>())  <span class="comment"># check img_size</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Multi-GPU disabled, incompatible with .half() https://github.com/ultralytics/yolov5/issues/99</span></span><br><span class="line">        <span class="comment"># if device.type != &#x27;cpu&#x27; and torch.cuda.device_count() &gt; 1:</span></span><br><span class="line">        <span class="comment">#     model = nn.DataParallel(model)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Half</span></span><br><span class="line">    half = device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span>  <span class="comment"># half precision only supported on CUDA</span></span><br><span class="line">    <span class="keyword">if</span> half:</span><br><span class="line">        model.half()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Configure</span></span><br><span class="line">    model.<span class="built_in">eval</span>() <span class="comment"># 表明是测试模式。会固定 BN 和 Dropout，用训练好的值；不启用 BatchNormalization 和 Dropout</span></span><br><span class="line">    is_coco = data.endswith(<span class="string">&#x27;coco.yaml&#x27;</span>)  <span class="comment"># is COCO dataset</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data) <span class="keyword">as</span> f:</span><br><span class="line">        data = yaml.load(f, Loader=yaml.FullLoader)  <span class="comment"># model dict</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># coco128.yaml 规定了 numbers of classes, train/val path, names of classes</span></span><br><span class="line">    check_dataset(data)  <span class="comment"># check 检查路径是否正确</span></span><br><span class="line">    nc = <span class="number">1</span> <span class="keyword">if</span> single_cls <span class="keyword">else</span> <span class="built_in">int</span>(data[<span class="string">&#x27;nc&#x27;</span>])  <span class="comment"># number of classes</span></span><br><span class="line">    iouv = torch.linspace(<span class="number">0.5</span>, <span class="number">0.95</span>, <span class="number">10</span>).to(device)  <span class="comment"># iou vector for mAP@0.5:0.95</span></span><br><span class="line">    niou = iouv.numel()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Logging</span></span><br><span class="line">    log_imgs, wandb = <span class="built_in">min</span>(log_imgs, <span class="number">100</span>), <span class="literal">None</span>  <span class="comment"># ceil</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> wandb  <span class="comment"># Weights &amp; Biases</span></span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        log_imgs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Dataloader 训练模式无需加载数据集</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> training:</span><br><span class="line">        img = torch.zeros((<span class="number">1</span>, <span class="number">3</span>, imgsz, imgsz), device=device)  <span class="comment"># init img</span></span><br><span class="line">        <span class="comment"># 模型试运行一次，检查模型是否正确</span></span><br><span class="line">        _ = model(img.half() <span class="keyword">if</span> half <span class="keyword">else</span> img) <span class="keyword">if</span> device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span> <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># run once </span></span><br><span class="line">        path = data[<span class="string">&#x27;test&#x27;</span>] <span class="keyword">if</span> opt.task == <span class="string">&#x27;test&#x27;</span> <span class="keyword">else</span> data[<span class="string">&#x27;val&#x27;</span>]  <span class="comment"># path to val/test images</span></span><br><span class="line">        dataloader = create_dataloader(path, imgsz, batch_size, model.stride.<span class="built_in">max</span>(), opt, pad=<span class="number">0.5</span>, rect=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    seen = <span class="number">0</span></span><br><span class="line">    confusion_matrix = ConfusionMatrix(nc=nc)</span><br><span class="line">    names = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(model.names <span class="keyword">if</span> <span class="built_in">hasattr</span>(model, <span class="string">&#x27;names&#x27;</span>) <span class="keyword">else</span> model.module.names)&#125;</span><br><span class="line">    coco91class = coco80_to_coco91_class()</span><br><span class="line">    s = (<span class="string">&#x27;%20s&#x27;</span> + <span class="string">&#x27;%12s&#x27;</span> * <span class="number">6</span>) % (<span class="string">&#x27;Class&#x27;</span>, <span class="string">&#x27;Images&#x27;</span>, <span class="string">&#x27;Targets&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;mAP@.5&#x27;</span>, <span class="string">&#x27;mAP@.5:.95&#x27;</span>)</span><br><span class="line">    p, r, f1, mp, mr, map50, <span class="built_in">map</span>, t0, t1 = <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span> <span class="comment"># 初始化输出结果变量</span></span><br><span class="line">    loss = torch.zeros(<span class="number">3</span>, device=device) <span class="comment"># 初始化测试损失变量</span></span><br><span class="line">    jdict, stats, ap, ap_class, wandb_images = [], [], [], [], [] <span class="comment"># 初始化 json 文件、结果统计信息、ap</span></span><br><span class="line">    <span class="keyword">for</span> batch_i, (img, targets, paths, shapes) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(dataloader, desc=s)):</span><br><span class="line">        img = img.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line">        img = img.half() <span class="keyword">if</span> half <span class="keyword">else</span> img.<span class="built_in">float</span>()  <span class="comment"># uint8 to fp16/32</span></span><br><span class="line">        img /= <span class="number">255.0</span>  <span class="comment"># 0 - 255 to 0.0 - 1.0</span></span><br><span class="line">        targets = targets.to(device)</span><br><span class="line">        nb, _, height, width = img.shape  <span class="comment"># batch size, channels, height, width</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="comment"># Run model</span></span><br><span class="line">            t = time_synchronized()</span><br><span class="line">            inf_out, train_out = model(img, augment=augment)  <span class="comment"># inference and training outputs</span></span><br><span class="line">            t0 += time_synchronized() - t</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Compute loss</span></span><br><span class="line">            <span class="keyword">if</span> training: <span class="comment"># 用于训练时计算损失，测试时用不到</span></span><br><span class="line">                loss += compute_loss([x.<span class="built_in">float</span>() <span class="keyword">for</span> x <span class="keyword">in</span> train_out], targets, model)[<span class="number">1</span>][:<span class="number">3</span>]  <span class="comment"># box, obj, cls</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Run NMS</span></span><br><span class="line">            targets[:, <span class="number">2</span>:] *= torch.Tensor([width, height, width, height]).to(device)  <span class="comment"># to pixels</span></span><br><span class="line">            lb = [targets[targets[:, <span class="number">0</span>] == i, <span class="number">1</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nb)] <span class="keyword">if</span> save_hybrid <span class="keyword">else</span> []  <span class="comment"># for autolabelling</span></span><br><span class="line">            t = time_synchronized()</span><br><span class="line">            output = non_max_suppression(inf_out, conf_thres=conf_thres, iou_thres=iou_thres, labels=lb)</span><br><span class="line">            t1 += time_synchronized() - t</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Statistics per image 为每一张图片做统计，写入预测信息到 txt 文件，生成 json 文件，统计信息</span></span><br><span class="line">        <span class="keyword">for</span> si, pred <span class="keyword">in</span> <span class="built_in">enumerate</span>(output):</span><br><span class="line">            <span class="comment"># 获取第 si 张图片的真实标签信息(ground truth)</span></span><br><span class="line">            labels = targets[targets[:, <span class="number">0</span>] == si, <span class="number">1</span>:] <span class="comment"># 取出图片标注信息</span></span><br><span class="line">            nl = <span class="built_in">len</span>(labels)</span><br><span class="line">            tcls = labels[:, <span class="number">0</span>].tolist() <span class="keyword">if</span> nl <span class="keyword">else</span> []  <span class="comment"># target class</span></span><br><span class="line">            path = Path(paths[si])</span><br><span class="line">            seen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pred) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nl:</span><br><span class="line">                    stats.append((torch.zeros(<span class="number">0</span>, niou, dtype=torch.<span class="built_in">bool</span>), torch.Tensor(), torch.Tensor(), tcls))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Predictions</span></span><br><span class="line">            predn = pred.clone()</span><br><span class="line">            scale_coords(img[si].shape[<span class="number">1</span>:], predn[:, :<span class="number">4</span>], shapes[si][<span class="number">0</span>], shapes[si][<span class="number">1</span>])  <span class="comment"># native-space pred</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append to text file</span></span><br><span class="line">            <span class="keyword">if</span> save_txt:</span><br><span class="line">                gn = torch.tensor(shapes[si][<span class="number">0</span>])[[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]  <span class="comment"># normalization gain whwh</span></span><br><span class="line">                <span class="keyword">for</span> *xyxy, conf, cls <span class="keyword">in</span> predn.tolist():</span><br><span class="line">                    xywh = (xyxy2xywh(torch.tensor(xyxy).view(<span class="number">1</span>, <span class="number">4</span>)) / gn).view(-<span class="number">1</span>).tolist()  <span class="comment"># normalized xywh</span></span><br><span class="line">                    line = (cls, *xywh, conf) <span class="keyword">if</span> save_conf <span class="keyword">else</span> (cls, *xywh)  <span class="comment"># label format</span></span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(save_dir / <span class="string">&#x27;labels&#x27;</span> / (path.stem + <span class="string">&#x27;.txt&#x27;</span>), <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write((<span class="string">&#x27;%g &#x27;</span> * <span class="built_in">len</span>(line)).rstrip() % line + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># W&amp;B logging</span></span><br><span class="line">            <span class="keyword">if</span> plots <span class="keyword">and</span> <span class="built_in">len</span>(wandb_images) &lt; log_imgs:</span><br><span class="line">                box_data = [&#123;<span class="string">&quot;position&quot;</span>: &#123;<span class="string">&quot;minX&quot;</span>: xyxy[<span class="number">0</span>], <span class="string">&quot;minY&quot;</span>: xyxy[<span class="number">1</span>], <span class="string">&quot;maxX&quot;</span>: xyxy[<span class="number">2</span>], <span class="string">&quot;maxY&quot;</span>: xyxy[<span class="number">3</span>]&#125;,</span><br><span class="line">                             <span class="string">&quot;class_id&quot;</span>: <span class="built_in">int</span>(cls),</span><br><span class="line">                             <span class="string">&quot;box_caption&quot;</span>: <span class="string">&quot;%s %.3f&quot;</span> % (names[cls], conf),</span><br><span class="line">                             <span class="string">&quot;scores&quot;</span>: &#123;<span class="string">&quot;class_score&quot;</span>: conf&#125;,</span><br><span class="line">                             <span class="string">&quot;domain&quot;</span>: <span class="string">&quot;pixel&quot;</span>&#125; <span class="keyword">for</span> *xyxy, conf, cls <span class="keyword">in</span> pred.tolist()]</span><br><span class="line">                boxes = &#123;<span class="string">&quot;predictions&quot;</span>: &#123;<span class="string">&quot;box_data&quot;</span>: box_data, <span class="string">&quot;class_labels&quot;</span>: names&#125;&#125;  <span class="comment"># inference-space</span></span><br><span class="line">                wandb_images.append(wandb.Image(img[si], boxes=boxes, caption=path.name))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append to pycocotools JSON dictionary</span></span><br><span class="line">            <span class="comment"># coco json 格式：xywh(xy是左上角坐标)</span></span><br><span class="line">            <span class="keyword">if</span> save_json:</span><br><span class="line">                <span class="comment"># [&#123;&quot;image_id&quot;: 42, &quot;category_id&quot;: 18, &quot;bbox&quot;: [258.15, 41.29, 348.26, 243.78], &quot;score&quot;: 0.236&#125;, ...</span></span><br><span class="line">                image_id = <span class="built_in">int</span>(path.stem) <span class="keyword">if</span> path.stem.isnumeric() <span class="keyword">else</span> path.stem</span><br><span class="line">                box = xyxy2xywh(predn[:, :<span class="number">4</span>])  <span class="comment"># xywh</span></span><br><span class="line">                box[:, :<span class="number">2</span>] -= box[:, <span class="number">2</span>:] / <span class="number">2</span>  <span class="comment"># xy center to top-left corner</span></span><br><span class="line">                <span class="keyword">for</span> p, b <span class="keyword">in</span> <span class="built_in">zip</span>(pred.tolist(), box.tolist()):</span><br><span class="line">                    jdict.append(&#123;<span class="string">&#x27;image_id&#x27;</span>: image_id,</span><br><span class="line">                                  <span class="string">&#x27;category_id&#x27;</span>: coco91class[<span class="built_in">int</span>(p[<span class="number">5</span>])] <span class="keyword">if</span> is_coco <span class="keyword">else</span> <span class="built_in">int</span>(p[<span class="number">5</span>]),</span><br><span class="line">                                  <span class="string">&#x27;bbox&#x27;</span>: [<span class="built_in">round</span>(x, <span class="number">3</span>) <span class="keyword">for</span> x <span class="keyword">in</span> b],</span><br><span class="line">                                  <span class="string">&#x27;score&#x27;</span>: <span class="built_in">round</span>(p[<span class="number">4</span>], <span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Assign all predictions as incorrect</span></span><br><span class="line">            <span class="comment"># 初始化预测评定，niou 为 iou 阈值的个数</span></span><br><span class="line">            correct = torch.zeros(pred.shape[<span class="number">0</span>], niou, dtype=torch.<span class="built_in">bool</span>, device=device)</span><br><span class="line">            <span class="keyword">if</span> nl:</span><br><span class="line">                detected = []  <span class="comment"># target indices</span></span><br><span class="line">                tcls_tensor = labels[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># target boxes</span></span><br><span class="line">                tbox = xywh2xyxy(labels[:, <span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line">                scale_coords(img[si].shape[<span class="number">1</span>:], tbox, shapes[si][<span class="number">0</span>], shapes[si][<span class="number">1</span>])  <span class="comment"># native-space labels</span></span><br><span class="line">                <span class="keyword">if</span> plots:</span><br><span class="line">                    confusion_matrix.process_batch(pred, torch.cat((labels[:, <span class="number">0</span>:<span class="number">1</span>], tbox), <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Per target class 对每个类单独处理</span></span><br><span class="line">                <span class="keyword">for</span> cls <span class="keyword">in</span> torch.unique(tcls_tensor):</span><br><span class="line">                    <span class="comment"># 标签框该类别的索引</span></span><br><span class="line">                    ti = (cls == tcls_tensor).nonzero(as_tuple=<span class="literal">False</span>).view(-<span class="number">1</span>)  <span class="comment"># prediction indices</span></span><br><span class="line">                    <span class="comment"># 预测框该类别的索引</span></span><br><span class="line">                    pi = (cls == pred[:, <span class="number">5</span>]).nonzero(as_tuple=<span class="literal">False</span>).view(-<span class="number">1</span>)  <span class="comment"># target indices</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># Search for detections</span></span><br><span class="line">                    <span class="keyword">if</span> pi.shape[<span class="number">0</span>]:</span><br><span class="line">                        <span class="comment"># Prediction to target ious</span></span><br><span class="line">                        <span class="comment"># 计算预测框与标签框的 iou 值，并选出最大的 ious，i 为对应索引</span></span><br><span class="line">                        ious, i = box_iou(predn[pi, :<span class="number">4</span>], tbox[ti]).<span class="built_in">max</span>(<span class="number">1</span>)  <span class="comment"># best ious, indices</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># Append detections</span></span><br><span class="line">                        detected_set = <span class="built_in">set</span>()</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> (ious &gt; iouv[<span class="number">0</span>]).nonzero(as_tuple=<span class="literal">False</span>):</span><br><span class="line">                            d = ti[i[j]]  <span class="comment"># detected target</span></span><br><span class="line">                            <span class="keyword">if</span> d.item() <span class="keyword">not</span> <span class="keyword">in</span> detected_set:</span><br><span class="line">                                detected_set.add(d.item())</span><br><span class="line">                                detected.append(d)</span><br><span class="line">                                <span class="comment"># iouv 以 0.05 为步长，0.05 到 0.95 的列表</span></span><br><span class="line">                                <span class="comment"># 获得不同 iou 阈值下的 true positive</span></span><br><span class="line">                                correct[pi[j]] = ious[j] &gt; iouv  <span class="comment"># iou_thres is 1xn</span></span><br><span class="line">                                <span class="keyword">if</span> <span class="built_in">len</span>(detected) == nl:  <span class="comment"># all targets already located in image</span></span><br><span class="line">                                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append statistics (correct, conf, pcls, tcls)</span></span><br><span class="line">            stats.append((correct.cpu(), pred[:, <span class="number">4</span>].cpu(), pred[:, <span class="number">5</span>].cpu(), tcls))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot images 分别画出前三个 batch 的真实标注框和预测框 </span></span><br><span class="line">        <span class="keyword">if</span> plots <span class="keyword">and</span> batch_i &lt; <span class="number">3</span>:</span><br><span class="line">            f = save_dir / <span class="string">f&#x27;test_batch<span class="subst">&#123;batch_i&#125;</span>_labels.jpg&#x27;</span>  <span class="comment"># labels</span></span><br><span class="line">            Thread(target=plot_images, args=(img, targets, paths, f, names), daemon=<span class="literal">True</span>).start()</span><br><span class="line">            f = save_dir / <span class="string">f&#x27;test_batch<span class="subst">&#123;batch_i&#125;</span>_pred.jpg&#x27;</span>  <span class="comment"># predictions</span></span><br><span class="line">            Thread(target=plot_images, args=(img, output_to_target(output), paths, f, names), daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute statistics</span></span><br><span class="line">    stats = [np.concatenate(x, <span class="number">0</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(*stats)]  <span class="comment"># to numpy</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stats) <span class="keyword">and</span> stats[<span class="number">0</span>].<span class="built_in">any</span>():</span><br><span class="line">        <span class="comment"># precision = TP/(TP+FP), recall = TP/P, mAP, f1 分数, 各类别 ap</span></span><br><span class="line">        p, r, ap, f1, ap_class = ap_per_class(*stats, plot=plots, save_dir=save_dir, names=names)</span><br><span class="line">        p, r, ap50, ap = p[:, <span class="number">0</span>], r[:, <span class="number">0</span>], ap[:, <span class="number">0</span>], ap.mean(<span class="number">1</span>)  <span class="comment"># [P, R, AP@0.5, AP@0.5:0.95]</span></span><br><span class="line">        mp, mr, map50, <span class="built_in">map</span> = p.mean(), r.mean(), ap50.mean(), ap.mean()</span><br><span class="line">        <span class="comment"># nt 是一个列表，表示测试集中每个类别有多少个目标框</span></span><br><span class="line">        nt = np.bincount(stats[<span class="number">3</span>].astype(np.int64), minlength=nc)  <span class="comment"># number of targets per class</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nt = torch.zeros(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print results</span></span><br><span class="line">    pf = <span class="string">&#x27;%20s&#x27;</span> + <span class="string">&#x27;%12.3g&#x27;</span> * <span class="number">6</span>  <span class="comment"># print format</span></span><br><span class="line">    <span class="built_in">print</span>(pf % (<span class="string">&#x27;all&#x27;</span>, seen, nt.<span class="built_in">sum</span>(), mp, mr, map50, <span class="built_in">map</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print results per class</span></span><br><span class="line">    <span class="keyword">if</span> verbose <span class="keyword">and</span> nc &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(stats):</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ap_class):</span><br><span class="line">            <span class="built_in">print</span>(pf % (names[c], seen, nt[c], p[i], r[i], ap50[i], ap[i]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print speeds</span></span><br><span class="line">    t = <span class="built_in">tuple</span>(x / seen * <span class="number">1E3</span> <span class="keyword">for</span> x <span class="keyword">in</span> (t0, t1, t0 + t1)) + (imgsz, imgsz, batch_size)  <span class="comment"># tuple</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> training:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Speed: %.1f/%.1f/%.1f ms inference/NMS/total per %gx%g image at batch-size %g&#x27;</span> % t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plots</span></span><br><span class="line">    <span class="keyword">if</span> plots:</span><br><span class="line">        confusion_matrix.plot(save_dir=save_dir, names=<span class="built_in">list</span>(names.values()))</span><br><span class="line">        <span class="keyword">if</span> wandb <span class="keyword">and</span> wandb.run:</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Images&quot;</span>: wandb_images&#125;)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Validation&quot;</span>: [wandb.Image(<span class="built_in">str</span>(f), caption=f.name) <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(save_dir.glob(<span class="string">&#x27;test*.jpg&#x27;</span>))]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save JSON</span></span><br><span class="line">    <span class="comment"># 采用之前保存的 json 格式预测实验结果，通过 cocoapi 评估指标</span></span><br><span class="line">    <span class="comment"># 测试集标签也要传换成 coco 的 json 格式</span></span><br><span class="line">    <span class="keyword">if</span> save_json <span class="keyword">and</span> <span class="built_in">len</span>(jdict):</span><br><span class="line">        w = Path(weights[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">isinstance</span>(weights, <span class="built_in">list</span>) <span class="keyword">else</span> weights).stem <span class="keyword">if</span> weights <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>  <span class="comment"># weights</span></span><br><span class="line">        anno_json = <span class="string">&#x27;../coco/annotations/instances_val2017.json&#x27;</span>  <span class="comment"># annotations json</span></span><br><span class="line">        pred_json = <span class="built_in">str</span>(save_dir / <span class="string">f&quot;<span class="subst">&#123;w&#125;</span>_predictions.json&quot;</span>)  <span class="comment"># predictions json</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nEvaluating pycocotools mAP... saving %s...&#x27;</span> % pred_json)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(pred_json, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(jdict, f)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:  <span class="comment"># https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb</span></span><br><span class="line">            <span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line">            <span class="keyword">from</span> pycocotools.cocoeval <span class="keyword">import</span> COCOeval</span><br><span class="line"></span><br><span class="line">            anno = COCO(anno_json)  <span class="comment"># init annotations api</span></span><br><span class="line">            pred = anno.loadRes(pred_json)  <span class="comment"># init predictions api</span></span><br><span class="line">            <span class="built_in">eval</span> = COCOeval(anno, pred, <span class="string">&#x27;bbox&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> is_coco:</span><br><span class="line">                <span class="built_in">eval</span>.params.imgIds = [<span class="built_in">int</span>(Path(x).stem) <span class="keyword">for</span> x <span class="keyword">in</span> dataloader.dataset.img_files]  <span class="comment"># image IDs to evaluate</span></span><br><span class="line">            <span class="built_in">eval</span>.evaluate()</span><br><span class="line">            <span class="built_in">eval</span>.accumulate()</span><br><span class="line">            <span class="built_in">eval</span>.summarize()</span><br><span class="line">            <span class="built_in">map</span>, map50 = <span class="built_in">eval</span>.stats[:<span class="number">2</span>]  <span class="comment"># update results (mAP@0.5:0.95, mAP@0.5)</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;pycocotools unable to run: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return results</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> training:</span><br><span class="line">        s = <span class="string">f&quot;\n<span class="subst">&#123;<span class="built_in">len</span>(<span class="built_in">list</span>(save_dir.glob(<span class="string">&#x27;labels/*.txt&#x27;</span>)))&#125;</span> labels saved to <span class="subst">&#123;save_dir / <span class="string">&#x27;labels&#x27;</span>&#125;</span>&quot;</span> <span class="keyword">if</span> save_txt <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Results saved to <span class="subst">&#123;save_dir&#125;</span><span class="subst">&#123;s&#125;</span>&quot;</span>)</span><br><span class="line">    model.<span class="built_in">float</span>()  <span class="comment"># for training</span></span><br><span class="line">    maps = np.zeros(nc) + <span class="built_in">map</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ap_class):</span><br><span class="line">        maps[c] = ap[i]</span><br><span class="line">    <span class="keyword">return</span> (mp, mr, map50, <span class="built_in">map</span>, *(loss.cpu() / <span class="built_in">len</span>(dataloader)).tolist()), maps, t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(prog=<span class="string">&#x27;test.py&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--weights&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;weights/yolov5s.pt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;model.pt path(s)&#x27;</span>) <span class="comment"># 权重文件路径</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;data/coco128.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;*.data path&#x27;</span>) <span class="comment"># 测试的数据集或者配置文件</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>, <span class="built_in">help</span>=<span class="string">&#x27;size of each image batch&#x27;</span>) <span class="comment"># batchsize</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--img-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">640</span>, <span class="built_in">help</span>=<span class="string">&#x27;inference size (pixels)&#x27;</span>) <span class="comment"># 输入模型的图片大小格式</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--conf-thres&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.001</span>, <span class="built_in">help</span>=<span class="string">&#x27;object confidence threshold&#x27;</span>) <span class="comment"># 置信度阈值</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--iou-thres&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.6</span>, <span class="built_in">help</span>=<span class="string">&#x27;IOU threshold for NMS&#x27;</span>) <span class="comment"># IoU阈值</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--task&#x27;</span>, default=<span class="string">&#x27;val&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;&#x27;val&#x27;, &#x27;test&#x27;, &#x27;study&#x27;&quot;</span>) <span class="comment"># 当前任务</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--device&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;cuda device, i.e. 0 or 0,1,2,3 or cpu&#x27;</span>) <span class="comment"># 设备</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--single-cls&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;treat as single-class dataset&#x27;</span>) <span class="comment"># 是否是做单类识别</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--augment&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;augmented inference&#x27;</span>) <span class="comment"># 数据增广</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--verbose&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;report mAP by class&#x27;</span>) <span class="comment"># 报告每类别的 mAP</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-txt&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save results to *.txt&#x27;</span>) <span class="comment"># 将预测框结果保留至 txt</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-hybrid&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save label+prediction hybrid results to *.txt&#x27;</span>) <span class="comment"># </span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-conf&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save confidences in --save-txt labels&#x27;</span>) <span class="comment"># 保留置信度阈值</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-json&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save a cocoapi-compatible JSON results file&#x27;</span>) <span class="comment">#</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--project&#x27;</span>, default=<span class="string">&#x27;runs/test&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save to project/name&#x27;</span>) <span class="comment"># 存放输出结果目录</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--name&#x27;</span>, default=<span class="string">&#x27;exp&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save to project/name&#x27;</span>) <span class="comment"># 输出结果存放文件夹</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--exist-ok&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;existing project/name ok, do not increment&#x27;</span>)</span><br><span class="line">    opt = parser.parse_args()</span><br><span class="line">    opt.save_json |= opt.data.endswith(<span class="string">&#x27;coco.yaml&#x27;</span>)</span><br><span class="line">    opt.data = check_file(opt.data)  <span class="comment"># check file 检查文件是否存在</span></span><br><span class="line">    <span class="built_in">print</span>(opt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> opt.task <span class="keyword">in</span> [<span class="string">&#x27;val&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]:  <span class="comment"># run normally</span></span><br><span class="line">        test(opt.data,</span><br><span class="line">             opt.weights,</span><br><span class="line">             opt.batch_size,</span><br><span class="line">             opt.img_size,</span><br><span class="line">             opt.conf_thres,</span><br><span class="line">             opt.iou_thres,</span><br><span class="line">             opt.save_json,</span><br><span class="line">             opt.single_cls,</span><br><span class="line">             opt.augment,</span><br><span class="line">             opt.verbose,</span><br><span class="line">             save_txt=opt.save_txt | opt.save_hybrid,</span><br><span class="line">             save_hybrid=opt.save_hybrid,</span><br><span class="line">             save_conf=opt.save_conf,</span><br><span class="line">             )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> opt.task == <span class="string">&#x27;study&#x27;</span>:  <span class="comment"># run over a range of settings and save/plot</span></span><br><span class="line">        <span class="keyword">for</span> weights <span class="keyword">in</span> [<span class="string">&#x27;yolov5s.pt&#x27;</span>, <span class="string">&#x27;yolov5m.pt&#x27;</span>, <span class="string">&#x27;yolov5l.pt&#x27;</span>, <span class="string">&#x27;yolov5x.pt&#x27;</span>]:</span><br><span class="line">            f = <span class="string">&#x27;study_%s_%s.txt&#x27;</span> % (Path(opt.data).stem, Path(weights).stem)  <span class="comment"># filename to save to</span></span><br><span class="line">            x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">320</span>, <span class="number">800</span>, <span class="number">64</span>))  <span class="comment"># x axis</span></span><br><span class="line">            y = []  <span class="comment"># y axis</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> x:  <span class="comment"># img-size</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\nRunning %s point %s...&#x27;</span> % (f, i))</span><br><span class="line">                r, _, t = test(opt.data, weights, opt.batch_size, i, opt.conf_thres, opt.iou_thres, opt.save_json,</span><br><span class="line">                               plots=<span class="literal">False</span>)</span><br><span class="line">                y.append(r + t)  <span class="comment"># results and times</span></span><br><span class="line">            np.savetxt(f, y, fmt=<span class="string">&#x27;%10.4g&#x27;</span>)  <span class="comment"># save</span></span><br><span class="line">        os.system(<span class="string">&#x27;zip -r study.zip study_*.txt&#x27;</span>)</span><br><span class="line">        plot_study_txt(f, x)  <span class="comment"># plot</span></span><br></pre></td></tr></table></figure></p>
<h4 id="train.py">train.py</h4>
<p><code>train.py</code> 训练模型的主要代码 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train.py 源码解读</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> warnings <span class="keyword">import</span> warn</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.optim.lr_scheduler <span class="keyword">as</span> lr_scheduler</span><br><span class="line"><span class="keyword">import</span> torch.utils.data</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">from</span> torch.cuda <span class="keyword">import</span> amp</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test  <span class="comment"># import test.py to get mAP after each epoch</span></span><br><span class="line"><span class="keyword">from</span> models.experimental <span class="keyword">import</span> attempt_load</span><br><span class="line"><span class="keyword">from</span> models.yolo <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> utils.autoanchor <span class="keyword">import</span> check_anchors</span><br><span class="line"><span class="keyword">from</span> utils.datasets <span class="keyword">import</span> create_dataloader</span><br><span class="line"><span class="keyword">from</span> utils.general <span class="keyword">import</span> labels_to_class_weights, increment_path, labels_to_image_weights, init_seeds, \</span><br><span class="line">    fitness, strip_optimizer, get_latest_run, check_dataset, check_file, check_git_status, check_img_size, \</span><br><span class="line">    print_mutation, set_logging, one_cycle</span><br><span class="line"><span class="keyword">from</span> utils.google_utils <span class="keyword">import</span> attempt_download</span><br><span class="line"><span class="keyword">from</span> utils.loss <span class="keyword">import</span> compute_loss</span><br><span class="line"><span class="keyword">from</span> utils.plots <span class="keyword">import</span> plot_images, plot_labels, plot_results, plot_evolution</span><br><span class="line"><span class="keyword">from</span> utils.torch_utils <span class="keyword">import</span> ModelEMA, select_device, intersect_dicts, torch_distributed_zero_first</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> wandb</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    wandb = <span class="literal">None</span></span><br><span class="line">    logger.info(<span class="string">&quot;Install Weights &amp; Biases for experiment logging via &#x27;pip install wandb&#x27; (recommended)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">hyp, opt, device, tb_writer=<span class="literal">None</span>, wandb=<span class="literal">None</span></span>):</span></span><br><span class="line">    logger.info(<span class="string">f&#x27;Hyperparameters <span class="subst">&#123;hyp&#125;</span>&#x27;</span>)</span><br><span class="line">    save_dir, epochs, batch_size, total_batch_size, weights, rank = \</span><br><span class="line">        Path(opt.save_dir), opt.epochs, opt.batch_size, opt.total_batch_size, opt.weights, opt.global_rank</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Directories</span></span><br><span class="line">    <span class="comment"># 设置权重保存路径</span></span><br><span class="line">    wdir = save_dir / <span class="string">&#x27;weights&#x27;</span></span><br><span class="line">    wdir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)  <span class="comment"># make dir 创建文件夹</span></span><br><span class="line">    last = wdir / <span class="string">&#x27;last.pt&#x27;</span></span><br><span class="line">    best = wdir / <span class="string">&#x27;best.pt&#x27;</span></span><br><span class="line">    <span class="comment"># 设置保存 result 的路径</span></span><br><span class="line">    results_file = save_dir / <span class="string">&#x27;results.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save run settings 保留训练后的配置信息(超参数、配置参数 opt)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(save_dir / <span class="string">&#x27;hyp.yaml&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        yaml.dump(hyp, f, sort_keys=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(save_dir / <span class="string">&#x27;opt.yaml&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        yaml.dump(<span class="built_in">vars</span>(opt), f, sort_keys=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Configure</span></span><br><span class="line">    plots = <span class="keyword">not</span> opt.evolve  <span class="comment"># create plots</span></span><br><span class="line">    cuda = device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">    init_seeds(<span class="number">2</span> + rank) <span class="comment"># 随机种子</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(opt.data) <span class="keyword">as</span> f:</span><br><span class="line">        data_dict = yaml.load(f, Loader=yaml.FullLoader)  <span class="comment"># data dict 加载数据集配置文件</span></span><br><span class="line">    <span class="keyword">with</span> torch_distributed_zero_first(rank):</span><br><span class="line">        check_dataset(data_dict)  <span class="comment"># check</span></span><br><span class="line">    <span class="comment"># 训练集路径</span></span><br><span class="line">    train_path = data_dict[<span class="string">&#x27;train&#x27;</span>]</span><br><span class="line">    <span class="comment"># 测试集路径</span></span><br><span class="line">    test_path = data_dict[<span class="string">&#x27;val&#x27;</span>]</span><br><span class="line">    nc = <span class="number">1</span> <span class="keyword">if</span> opt.single_cls <span class="keyword">else</span> <span class="built_in">int</span>(data_dict[<span class="string">&#x27;nc&#x27;</span>])  <span class="comment"># number of classes</span></span><br><span class="line">    names = [<span class="string">&#x27;item&#x27;</span>] <span class="keyword">if</span> opt.single_cls <span class="keyword">and</span> <span class="built_in">len</span>(data_dict[<span class="string">&#x27;names&#x27;</span>]) != <span class="number">1</span> <span class="keyword">else</span> data_dict[<span class="string">&#x27;names&#x27;</span>]  <span class="comment"># class names</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(names) == nc, <span class="string">&#x27;%g names found for nc=%g dataset in %s&#x27;</span> % (<span class="built_in">len</span>(names), nc, opt.data)  <span class="comment"># check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Model</span></span><br><span class="line">    pretrained = weights.endswith(<span class="string">&#x27;.pt&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        <span class="keyword">with</span> torch_distributed_zero_first(rank):</span><br><span class="line">            attempt_download(weights)  <span class="comment"># download if not found locally</span></span><br><span class="line">        ckpt = torch.load(weights, map_location=device)  <span class="comment"># load checkpoint 加载预训练模型</span></span><br><span class="line">        <span class="keyword">if</span> hyp.get(<span class="string">&#x27;anchors&#x27;</span>):</span><br><span class="line">            ckpt[<span class="string">&#x27;model&#x27;</span>].yaml[<span class="string">&#x27;anchors&#x27;</span>] = <span class="built_in">round</span>(hyp[<span class="string">&#x27;anchors&#x27;</span>])  <span class="comment"># force autoanchor</span></span><br><span class="line">        model = Model(opt.cfg <span class="keyword">or</span> ckpt[<span class="string">&#x27;model&#x27;</span>].yaml, ch=<span class="number">3</span>, nc=nc).to(device)  <span class="comment"># create</span></span><br><span class="line">        exclude = [<span class="string">&#x27;anchor&#x27;</span>] <span class="keyword">if</span> opt.cfg <span class="keyword">or</span> hyp.get(<span class="string">&#x27;anchors&#x27;</span>) <span class="keyword">else</span> []  <span class="comment"># exclude keys</span></span><br><span class="line">        state_dict = ckpt[<span class="string">&#x27;model&#x27;</span>].<span class="built_in">float</span>().state_dict()  <span class="comment"># to FP32</span></span><br><span class="line">        state_dict = intersect_dicts(state_dict, model.state_dict(), exclude=exclude)  <span class="comment"># intersect (去除了一些层)</span></span><br><span class="line">        model.load_state_dict(state_dict, strict=<span class="literal">False</span>)  <span class="comment"># load 加载模型参数</span></span><br><span class="line">        logger.info(<span class="string">&#x27;Transferred %g/%g items from %s&#x27;</span> % (<span class="built_in">len</span>(state_dict), <span class="built_in">len</span>(model.state_dict()), weights))  <span class="comment"># report</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model = Model(opt.cfg, ch=<span class="number">3</span>, nc=nc).to(device)  <span class="comment"># create</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Freeze</span></span><br><span class="line">    freeze = []  <span class="comment"># parameter names to freeze (full or partial)</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        v.requires_grad = <span class="literal">True</span>  <span class="comment"># train all layers</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">in</span> k <span class="keyword">for</span> x <span class="keyword">in</span> freeze):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;freezing %s&#x27;</span> % k)</span><br><span class="line">            v.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Optimizer</span></span><br><span class="line">    nbs = <span class="number">64</span>  <span class="comment"># nominal batch size</span></span><br><span class="line">    accumulate = <span class="built_in">max</span>(<span class="built_in">round</span>(nbs / total_batch_size), <span class="number">1</span>)  <span class="comment"># accumulate loss before optimizing</span></span><br><span class="line">    hyp[<span class="string">&#x27;weight_decay&#x27;</span>] *= total_batch_size * accumulate / nbs  <span class="comment"># scale weight_decay 权重衰减</span></span><br><span class="line">    logger.info(<span class="string">f&quot;Scaled weight_decay = <span class="subst">&#123;hyp[<span class="string">&#x27;weight_decay&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将需要优化的参数分成三组</span></span><br><span class="line">    pg0, pg1, pg2 = [], [], []  <span class="comment"># optimizer parameter groups</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> model.named_modules():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(v, <span class="string">&#x27;bias&#x27;</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(v.bias, nn.Parameter):</span><br><span class="line">            pg2.append(v.bias)  <span class="comment"># biases 偏置项</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, nn.BatchNorm2d):</span><br><span class="line">            pg0.append(v.weight)  <span class="comment"># no decay 不进行权重衰减</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">hasattr</span>(v, <span class="string">&#x27;weight&#x27;</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(v.weight, nn.Parameter):</span><br><span class="line">            pg1.append(v.weight)  <span class="comment"># apply decay 进行权重衰减</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> opt.adam:</span><br><span class="line">        optimizer = optim.Adam(pg0, lr=hyp[<span class="string">&#x27;lr0&#x27;</span>], betas=(hyp[<span class="string">&#x27;momentum&#x27;</span>], <span class="number">0.999</span>))  <span class="comment"># adjust beta1 to momentum</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        optimizer = optim.SGD(pg0, lr=hyp[<span class="string">&#x27;lr0&#x27;</span>], momentum=hyp[<span class="string">&#x27;momentum&#x27;</span>], nesterov=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    optimizer.add_param_group(&#123;<span class="string">&#x27;params&#x27;</span>: pg1, <span class="string">&#x27;weight_decay&#x27;</span>: hyp[<span class="string">&#x27;weight_decay&#x27;</span>]&#125;)  <span class="comment"># add pg1 with weight_decay</span></span><br><span class="line">    optimizer.add_param_group(&#123;<span class="string">&#x27;params&#x27;</span>: pg2&#125;)  <span class="comment"># add pg2 (biases)</span></span><br><span class="line">    logger.info(<span class="string">&#x27;Optimizer groups: %g .bias, %g conv.weight, %g other&#x27;</span> % (<span class="built_in">len</span>(pg2), <span class="built_in">len</span>(pg1), <span class="built_in">len</span>(pg0)))</span><br><span class="line">    <span class="keyword">del</span> pg0, pg1, pg2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Scheduler https://arxiv.org/pdf/1812.01187.pdf</span></span><br><span class="line">    <span class="comment"># https://pytorch.org/docs/stable/_modules/torch/optim/lr_scheduler.html#OneCycleLR</span></span><br><span class="line">    lf = one_cycle(<span class="number">1</span>, hyp[<span class="string">&#x27;lrf&#x27;</span>], epochs)  <span class="comment"># cosine 1-&gt;hyp[&#x27;lrf&#x27;] 学习率使用余弦退火</span></span><br><span class="line">    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf) <span class="comment"># 学习率调整类实例化</span></span><br><span class="line">    <span class="comment"># plot_lr_scheduler(optimizer, scheduler, epochs)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Logging</span></span><br><span class="line">    <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>] <span class="keyword">and</span> wandb <span class="keyword">and</span> wandb.run <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        opt.hyp = hyp  <span class="comment"># add hyperparameters</span></span><br><span class="line">        wandb_run = wandb.init(config=opt, resume=<span class="string">&quot;allow&quot;</span>,</span><br><span class="line">                               project=<span class="string">&#x27;YOLOv5&#x27;</span> <span class="keyword">if</span> opt.project == <span class="string">&#x27;runs/train&#x27;</span> <span class="keyword">else</span> Path(opt.project).stem,</span><br><span class="line">                               name=save_dir.stem,</span><br><span class="line">                               <span class="built_in">id</span>=ckpt.get(<span class="string">&#x27;wandb_id&#x27;</span>) <span class="keyword">if</span> <span class="string">&#x27;ckpt&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">else</span> <span class="literal">None</span>)</span><br><span class="line">    loggers = &#123;<span class="string">&#x27;wandb&#x27;</span>: wandb&#125;  <span class="comment"># loggers dict</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Resume</span></span><br><span class="line">    start_epoch, best_fitness = <span class="number">0</span>, <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        <span class="comment"># Optimizer</span></span><br><span class="line">        <span class="keyword">if</span> ckpt[<span class="string">&#x27;optimizer&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            optimizer.load_state_dict(ckpt[<span class="string">&#x27;optimizer&#x27;</span>])</span><br><span class="line">            best_fitness = ckpt[<span class="string">&#x27;best_fitness&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Results</span></span><br><span class="line">        <span class="keyword">if</span> ckpt.get(<span class="string">&#x27;training_results&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(results_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file.write(ckpt[<span class="string">&#x27;training_results&#x27;</span>])  <span class="comment"># write results.txt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Epochs</span></span><br><span class="line">        start_epoch = ckpt[<span class="string">&#x27;epoch&#x27;</span>] + <span class="number">1</span> <span class="comment"># 非 resume 为零；resume则接着上次训练的 epoch</span></span><br><span class="line">        <span class="keyword">if</span> opt.resume:</span><br><span class="line">            <span class="keyword">assert</span> start_epoch &gt; <span class="number">0</span>, <span class="string">&#x27;%s training to %g epochs is finished, nothing to resume.&#x27;</span> % (weights, epochs)</span><br><span class="line">        <span class="keyword">if</span> epochs &lt; start_epoch: <span class="comment"># 若epochs 小于 start_epoch，则认为还需要训练 epochs 个 epoch。</span></span><br><span class="line">            logger.info(<span class="string">&#x27;%s has been trained for %g epochs. Fine-tuning for %g additional epochs.&#x27;</span> %</span><br><span class="line">                        (weights, ckpt[<span class="string">&#x27;epoch&#x27;</span>], epochs))</span><br><span class="line">            epochs += ckpt[<span class="string">&#x27;epoch&#x27;</span>]  <span class="comment"># finetune additional epochs</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">del</span> ckpt, state_dict</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Image sizes</span></span><br><span class="line">    gs = <span class="built_in">int</span>(model.stride.<span class="built_in">max</span>())  <span class="comment"># grid size (max stride)</span></span><br><span class="line">    nl = model.model[-<span class="number">1</span>].nl  <span class="comment"># number of detection layers (used for scaling hyp[&#x27;obj&#x27;]) 检测层的个数(有几个特征层融合)</span></span><br><span class="line">    imgsz, imgsz_test = [check_img_size(x, gs) <span class="keyword">for</span> x <span class="keyword">in</span> opt.img_size]  <span class="comment"># verify imgsz are gs-multiples</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># DP mode</span></span><br><span class="line">    <span class="keyword">if</span> cuda <span class="keyword">and</span> rank == -<span class="number">1</span> <span class="keyword">and</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">        model = torch.nn.DataParallel(model)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SyncBatchNorm</span></span><br><span class="line">    <span class="keyword">if</span> opt.sync_bn <span class="keyword">and</span> cuda <span class="keyword">and</span> rank != -<span class="number">1</span>:</span><br><span class="line">        model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)</span><br><span class="line">        logger.info(<span class="string">&#x27;Using SyncBatchNorm()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># EMA</span></span><br><span class="line">    ema = ModelEMA(model) <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>] <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># DDP mode</span></span><br><span class="line">    <span class="keyword">if</span> cuda <span class="keyword">and</span> rank != -<span class="number">1</span>:</span><br><span class="line">        model = DDP(model, device_ids=[opt.local_rank], output_device=opt.local_rank)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Trainloader 训练数据集</span></span><br><span class="line">    dataloader, dataset = create_dataloader(train_path, imgsz, batch_size, gs, opt,</span><br><span class="line">                                            hyp=hyp, augment=<span class="literal">True</span>, cache=opt.cache_images, rect=opt.rect, rank=rank,</span><br><span class="line">                                            world_size=opt.world_size, workers=opt.workers,</span><br><span class="line">                                            image_weights=opt.image_weights, quad=opt.quad)</span><br><span class="line">    mlc = np.concatenate(dataset.labels, <span class="number">0</span>)[:, <span class="number">0</span>].<span class="built_in">max</span>()  <span class="comment"># max label class 求最大的标签类别</span></span><br><span class="line">    nb = <span class="built_in">len</span>(dataloader)  <span class="comment"># number of batches</span></span><br><span class="line">    <span class="keyword">assert</span> mlc &lt; nc, <span class="string">&#x27;Label class %g exceeds nc=%g in %s. Possible class labels are 0-%g&#x27;</span> % (mlc, nc, opt.data, nc - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process 0</span></span><br><span class="line">    <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">        ema.updates = start_epoch * nb // accumulate  <span class="comment"># set EMA updates</span></span><br><span class="line">        <span class="comment"># 测试数据集</span></span><br><span class="line">        testloader = create_dataloader(test_path, imgsz_test, total_batch_size, gs, opt,  <span class="comment"># testloader</span></span><br><span class="line">                                       hyp=hyp, cache=opt.cache_images <span class="keyword">and</span> <span class="keyword">not</span> opt.notest, rect=<span class="literal">True</span>,</span><br><span class="line">                                       rank=-<span class="number">1</span>, world_size=opt.world_size, workers=opt.workers, pad=<span class="number">0.5</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> opt.resume:</span><br><span class="line">            labels = np.concatenate(dataset.labels, <span class="number">0</span>) <span class="comment"># 将所有的训练数据标签信息合并</span></span><br><span class="line">            c = torch.tensor(labels[:, <span class="number">0</span>])  <span class="comment"># classes 将类别信息提取出来</span></span><br><span class="line">            <span class="comment"># cf = torch.bincount(c.long(), minlength=nc) + 1.  # frequency</span></span><br><span class="line">            <span class="comment"># model._initialize_biases(cf.to(device))</span></span><br><span class="line">            <span class="keyword">if</span> plots:</span><br><span class="line">                plot_labels(labels, save_dir, loggers) <span class="comment"># 画出所有的标签框</span></span><br><span class="line">                <span class="keyword">if</span> tb_writer:</span><br><span class="line">                    tb_writer.add_histogram(<span class="string">&#x27;classes&#x27;</span>, c, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Anchors</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> opt.noautoanchor: <span class="comment"># 使用自动计算锚框</span></span><br><span class="line">                check_anchors(dataset, model=model, thr=hyp[<span class="string">&#x27;anchor_t&#x27;</span>], imgsz=imgsz)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Model parameters</span></span><br><span class="line">    <span class="comment"># 根据自己数据集的类别数设置分类损失的系数</span></span><br><span class="line">    hyp[<span class="string">&#x27;cls&#x27;</span>] *= nc / <span class="number">80.</span>  <span class="comment"># scale hyp[&#x27;cls&#x27;] to class count</span></span><br><span class="line">    hyp[<span class="string">&#x27;obj&#x27;</span>] *= imgsz ** <span class="number">2</span> / <span class="number">640.</span> ** <span class="number">2</span> * <span class="number">3.</span> / nl  <span class="comment"># scale hyp[&#x27;obj&#x27;] to image size and output layers</span></span><br><span class="line">    model.nc = nc  <span class="comment"># attach number of classes to model</span></span><br><span class="line">    model.hyp = hyp  <span class="comment"># attach hyperparameters to model</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    tobj[b,a,gj,gi] = (1.0 - gr) + model.gr*iou.detach().clamp(0).type(tobj.dtype)</span></span><br><span class="line"><span class="string">    这里 gr = 1, 也就是完全使用标签框与预测框的 IoU 作为该预测框的 objectness 标签</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model.gr = <span class="number">1.0</span>  <span class="comment"># iou loss ratio (obj_loss = 1.0 or iou) # 使用标签框与预测框的 iou 作为该预测框的 objectness 标签</span></span><br><span class="line">    <span class="comment"># 使用训练样本标签获得权重(与类别中的目标数目成反比)</span></span><br><span class="line">    model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  <span class="comment"># attach class weights</span></span><br><span class="line">    <span class="comment"># 类别名称</span></span><br><span class="line">    model.names = names</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start training</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    <span class="comment"># 获取热身训练的迭代次数</span></span><br><span class="line">    nw = <span class="built_in">max</span>(<span class="built_in">round</span>(hyp[<span class="string">&#x27;warmup_epochs&#x27;</span>] * nb), <span class="number">1000</span>)  <span class="comment"># number of warmup iterations, max(3 epochs, 1k iterations)</span></span><br><span class="line">    <span class="comment"># nw = min(nw, (epochs - start_epoch) / 2 * nb)  # limit warmup to &lt; 1/2 of training</span></span><br><span class="line">    maps = np.zeros(nc)  <span class="comment"># mAP per class</span></span><br><span class="line">    results = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)</span></span><br><span class="line">    <span class="comment"># 设置学习率衰减进行到的轮次，目的是打断训练之后，--resume 接着训练也能正常衔接之前的学习率衰减</span></span><br><span class="line">    scheduler.last_epoch = start_epoch - <span class="number">1</span>  <span class="comment"># do not move</span></span><br><span class="line">    <span class="comment"># 通过 torch 1.6 以上带的 api 进行混合精度训练</span></span><br><span class="line">    scaler = amp.GradScaler(enabled=cuda)</span><br><span class="line">    logger.info(<span class="string">&#x27;Image sizes %g train, %g test\n&#x27;</span></span><br><span class="line">                <span class="string">&#x27;Using %g dataloader workers\nLogging results to %s\n&#x27;</span></span><br><span class="line">                <span class="string">&#x27;Starting training for %g epochs...&#x27;</span> % (imgsz, imgsz_test, dataloader.num_workers, save_dir, epochs))</span><br><span class="line">    <span class="comment"># 开始训练</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(start_epoch, epochs):  <span class="comment"># epoch ------------------------------------------------------------------</span></span><br><span class="line">        model.train() <span class="comment"># 模型设置为训练模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update image weights (optional)</span></span><br><span class="line">        <span class="keyword">if</span> opt.image_weights:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            如果设置进行图片采样策略</span></span><br><span class="line"><span class="string">            则根据前面初始化的图片采样权重 model.class_weights 以及 maps 配合每张图片包含的类别数</span></span><br><span class="line"><span class="string">            通过 random.choices 生成图片索引 indeces 从而进行采样</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># Generate indices</span></span><br><span class="line">            <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">                cw = model.class_weights.cpu().numpy() * (<span class="number">1</span> - maps) ** <span class="number">2</span> / nc  <span class="comment"># class weights</span></span><br><span class="line">                iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  <span class="comment"># image weights</span></span><br><span class="line">                dataset.indices = random.choices(<span class="built_in">range</span>(dataset.n), weights=iw, k=dataset.n)  <span class="comment"># rand weighted idx</span></span><br><span class="line">            <span class="comment"># Broadcast if DDP DDP模式则采用广播采样策略</span></span><br><span class="line">            <span class="keyword">if</span> rank != -<span class="number">1</span>:</span><br><span class="line">                indices = (torch.tensor(dataset.indices) <span class="keyword">if</span> rank == <span class="number">0</span> <span class="keyword">else</span> torch.zeros(dataset.n)).<span class="built_in">int</span>()</span><br><span class="line">                dist.broadcast(indices, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> rank != <span class="number">0</span>:</span><br><span class="line">                    dataset.indices = indices.cpu().numpy()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update mosaic border</span></span><br><span class="line">        <span class="comment"># b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)</span></span><br><span class="line">        <span class="comment"># dataset.mosaic_border = [b - imgsz, -b]  # height, width borders</span></span><br><span class="line">        <span class="comment"># 初始化训练时的平均损失信息</span></span><br><span class="line">        mloss = torch.zeros(<span class="number">4</span>, device=device)  <span class="comment"># mean losses</span></span><br><span class="line">        <span class="comment"># DDP 模式下打乱数据，ddp.sampler 基于 epoch + seed 作为随机种子</span></span><br><span class="line">        <span class="keyword">if</span> rank != -<span class="number">1</span>:</span><br><span class="line">            dataloader.sampler.set_epoch(epoch)</span><br><span class="line">        pbar = <span class="built_in">enumerate</span>(dataloader) <span class="comment"># 作为进度条使用</span></span><br><span class="line">        <span class="comment"># 日志信息</span></span><br><span class="line">        logger.info((<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;%10s&#x27;</span> * <span class="number">8</span>) % (<span class="string">&#x27;Epoch&#x27;</span>, <span class="string">&#x27;gpu_mem&#x27;</span>, <span class="string">&#x27;box&#x27;</span>, <span class="string">&#x27;obj&#x27;</span>, <span class="string">&#x27;cls&#x27;</span>, <span class="string">&#x27;total&#x27;</span>, <span class="string">&#x27;targets&#x27;</span>, <span class="string">&#x27;img_size&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">            pbar = tqdm(pbar, total=nb)  <span class="comment"># progress bar 创建进度条</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始每一个 batchsize 训练</span></span><br><span class="line">        <span class="keyword">for</span> i, (imgs, targets, paths, _) <span class="keyword">in</span> pbar:  <span class="comment"># batch -------------------------------------------------------------</span></span><br><span class="line">            ni = i + nb * epoch  <span class="comment"># number integrated batches (since train start)</span></span><br><span class="line">            imgs = imgs.to(device, non_blocking=<span class="literal">True</span>).<span class="built_in">float</span>() / <span class="number">255.0</span>  <span class="comment"># uint8 to float32, 0-255 to 0.0-1.0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Warmup</span></span><br><span class="line">            <span class="keyword">if</span> ni &lt;= nw:</span><br><span class="line">                xi = [<span class="number">0</span>, nw]  <span class="comment"># x interp</span></span><br><span class="line">                <span class="comment"># model.gr = np.interp(ni, xi, [0.0, 1.0])  # iou loss ratio (obj_loss = 1.0 or iou)</span></span><br><span class="line">                accumulate = <span class="built_in">max</span>(<span class="number">1</span>, np.interp(ni, xi, [<span class="number">1</span>, nbs / total_batch_size]).<span class="built_in">round</span>())</span><br><span class="line">                <span class="keyword">for</span> j, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(optimizer.param_groups):</span><br><span class="line">                    <span class="comment"># bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0</span></span><br><span class="line">                    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    bias 学习率从 0.1 下降到 lr * lf(epoch)</span></span><br><span class="line"><span class="string">                    其他的参数学习率从 0 增加到 lr * lf(epoch)</span></span><br><span class="line"><span class="string">                    lf 为上面设置的余弦退火衰减函数</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span></span><br><span class="line">                    x[<span class="string">&#x27;lr&#x27;</span>] = np.interp(ni, xi, [hyp[<span class="string">&#x27;warmup_bias_lr&#x27;</span>] <span class="keyword">if</span> j == <span class="number">2</span> <span class="keyword">else</span> <span class="number">0.0</span>, x[<span class="string">&#x27;initial_lr&#x27;</span>] * lf(epoch)])</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&#x27;momentum&#x27;</span> <span class="keyword">in</span> x:</span><br><span class="line">                        x[<span class="string">&#x27;momentum&#x27;</span>] = np.interp(ni, xi, [hyp[<span class="string">&#x27;warmup_momentum&#x27;</span>], hyp[<span class="string">&#x27;momentum&#x27;</span>]])</span><br><span class="line">            <span class="comment"># 设置多尺度训练  从 imgsz * 0.5, imgsz * 1.5 + gs 中随机选取 </span></span><br><span class="line">            <span class="comment"># Multi-scale</span></span><br><span class="line">            <span class="keyword">if</span> opt.multi_scale:</span><br><span class="line">                sz = random.randrange(imgsz * <span class="number">0.5</span>, imgsz * <span class="number">1.5</span> + gs) // gs * gs  <span class="comment"># size</span></span><br><span class="line">                sf = sz / <span class="built_in">max</span>(imgs.shape[<span class="number">2</span>:])  <span class="comment"># scale factor</span></span><br><span class="line">                <span class="keyword">if</span> sf != <span class="number">1</span>:</span><br><span class="line">                    ns = [math.ceil(x * sf / gs) * gs <span class="keyword">for</span> x <span class="keyword">in</span> imgs.shape[<span class="number">2</span>:]]  <span class="comment"># new shape (stretched to gs-multiple)</span></span><br><span class="line">                    imgs = F.interpolate(imgs, size=ns, mode=<span class="string">&#x27;bilinear&#x27;</span>, align_corners=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Forward</span></span><br><span class="line">            <span class="keyword">with</span> amp.autocast(enabled=cuda): <span class="comment"># 只有 forward 和 loss 计算使用混合精度</span></span><br><span class="line">                pred = model(imgs)  <span class="comment"># forward</span></span><br><span class="line">                loss, loss_items = compute_loss(pred, targets.to(device), model)  <span class="comment"># loss scaled by batch_size</span></span><br><span class="line">                <span class="keyword">if</span> rank != -<span class="number">1</span>:</span><br><span class="line">                    loss *= opt.world_size  <span class="comment"># gradient averaged between devices in DDP mode</span></span><br><span class="line">                <span class="keyword">if</span> opt.quad:</span><br><span class="line">                    loss *= <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Backward</span></span><br><span class="line">            scaler.scale(loss).backward() <span class="comment"># 反向传播：Scales loss. 为了梯度放大</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Optimize</span></span><br><span class="line">            <span class="keyword">if</span> ni % accumulate == <span class="number">0</span>: <span class="comment"># 累计梯度后再更新。相当于扩大了 batchsize</span></span><br><span class="line">                <span class="comment"># scaler.step() 首先把梯度的值 unscale 回来</span></span><br><span class="line">                <span class="comment"># 如果梯度的值不是 infs 或 NaNs，那么调用 optimizer.step() 来更新权重</span></span><br><span class="line">                <span class="comment"># 否则，忽略 step 调用，从而保证权重不更新（不被破坏）</span></span><br><span class="line">                scaler.step(optimizer)  <span class="comment"># optimizer.step</span></span><br><span class="line">                scaler.update()</span><br><span class="line">                optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">                <span class="keyword">if</span> ema:</span><br><span class="line">                    ema.update(model)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Print</span></span><br><span class="line">            <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">                mloss = (mloss * i + loss_items) / (i + <span class="number">1</span>)  <span class="comment"># update mean losses</span></span><br><span class="line">                mem = <span class="string">&#x27;%.3gG&#x27;</span> % (torch.cuda.memory_reserved() / <span class="number">1E9</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># (GB)</span></span><br><span class="line">                s = (<span class="string">&#x27;%10s&#x27;</span> * <span class="number">2</span> + <span class="string">&#x27;%10.4g&#x27;</span> * <span class="number">6</span>) % (</span><br><span class="line">                    <span class="string">&#x27;%g/%g&#x27;</span> % (epoch, epochs - <span class="number">1</span>), mem, *mloss, targets.shape[<span class="number">0</span>], imgs.shape[-<span class="number">1</span>])</span><br><span class="line">                pbar.set_description(s)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Plot</span></span><br><span class="line">                <span class="comment"># 将前三次 batch 的带标签框图片输出保存</span></span><br><span class="line">                <span class="keyword">if</span> plots <span class="keyword">and</span> ni &lt; <span class="number">3</span>:</span><br><span class="line">                    f = save_dir / <span class="string">f&#x27;train_batch<span class="subst">&#123;ni&#125;</span>.jpg&#x27;</span>  <span class="comment"># filename</span></span><br><span class="line">                    Thread(target=plot_images, args=(imgs, targets, paths, f), daemon=<span class="literal">True</span>).start()</span><br><span class="line">                    <span class="comment"># if tb_writer:</span></span><br><span class="line">                    <span class="comment">#     tb_writer.add_image(f, result, dataformats=&#x27;HWC&#x27;, global_step=epoch)</span></span><br><span class="line">                    <span class="comment">#     tb_writer.add_graph(model, imgs)  # add model to tensorboard</span></span><br><span class="line">                <span class="keyword">elif</span> plots <span class="keyword">and</span> ni == <span class="number">3</span> <span class="keyword">and</span> wandb:</span><br><span class="line">                    wandb.log(&#123;<span class="string">&quot;Mosaics&quot;</span>: [wandb.Image(<span class="built_in">str</span>(x), caption=x.name) <span class="keyword">for</span> x <span class="keyword">in</span> save_dir.glob(<span class="string">&#x27;train*.jpg&#x27;</span>)]&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># end batch ------------------------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 进行学习率衰减</span></span><br><span class="line">        <span class="comment"># Scheduler </span></span><br><span class="line">        lr = [x[<span class="string">&#x27;lr&#x27;</span>] <span class="keyword">for</span> x <span class="keyword">in</span> optimizer.param_groups]  <span class="comment"># for tensorboard 保留上一次的学习率，用于日志输出</span></span><br><span class="line">        scheduler.step() <span class="comment"># 对学习率调整</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># DDP process 0 or single-GPU</span></span><br><span class="line">        <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># mAP</span></span><br><span class="line">            <span class="comment"># 更新 EMA 属性</span></span><br><span class="line">            <span class="comment"># 添加 include 属性</span></span><br><span class="line">            <span class="keyword">if</span> ema:</span><br><span class="line">                ema.update_attr(model, include=[<span class="string">&#x27;yaml&#x27;</span>, <span class="string">&#x27;nc&#x27;</span>, <span class="string">&#x27;hyp&#x27;</span>, <span class="string">&#x27;gr&#x27;</span>, <span class="string">&#x27;names&#x27;</span>, <span class="string">&#x27;stride&#x27;</span>, <span class="string">&#x27;class_weights&#x27;</span>])</span><br><span class="line">            <span class="comment"># 判断是否是最后一轮</span></span><br><span class="line">            final_epoch = epoch + <span class="number">1</span> == epochs</span><br><span class="line">            <span class="comment"># 对测试集进行测试，计算 mAP 等指标</span></span><br><span class="line">            <span class="comment"># 测试时使用的是 EMA 模型</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> opt.notest <span class="keyword">or</span> final_epoch:  <span class="comment"># Calculate mAP</span></span><br><span class="line">                results, maps, times = test.test(opt.data,</span><br><span class="line">                                                 batch_size=total_batch_size,</span><br><span class="line">                                                 imgsz=imgsz_test,</span><br><span class="line">                                                 model=ema.ema,</span><br><span class="line">                                                 single_cls=opt.single_cls,</span><br><span class="line">                                                 dataloader=testloader,</span><br><span class="line">                                                 save_dir=save_dir,</span><br><span class="line">                                                 plots=plots <span class="keyword">and</span> final_epoch,</span><br><span class="line">                                                 log_imgs=opt.log_imgs <span class="keyword">if</span> wandb <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Write</span></span><br><span class="line">            <span class="comment"># 将指标写入 result.txt</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(results_file, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(s + <span class="string">&#x27;%10.4g&#x27;</span> * <span class="number">7</span> % results + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(opt.name) <span class="keyword">and</span> opt.bucket:</span><br><span class="line">                os.system(<span class="string">&#x27;gsutil cp %s gs://%s/results/results%s.txt&#x27;</span> % (results_file, opt.bucket, opt.name))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Log</span></span><br><span class="line">            tags = [<span class="string">&#x27;train/box_loss&#x27;</span>, <span class="string">&#x27;train/obj_loss&#x27;</span>, <span class="string">&#x27;train/cls_loss&#x27;</span>,  <span class="comment"># train loss</span></span><br><span class="line">                    <span class="string">&#x27;metrics/precision&#x27;</span>, <span class="string">&#x27;metrics/recall&#x27;</span>, <span class="string">&#x27;metrics/mAP_0.5&#x27;</span>, <span class="string">&#x27;metrics/mAP_0.5:0.95&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;val/box_loss&#x27;</span>, <span class="string">&#x27;val/obj_loss&#x27;</span>, <span class="string">&#x27;val/cls_loss&#x27;</span>,  <span class="comment"># val loss</span></span><br><span class="line">                    <span class="string">&#x27;x/lr0&#x27;</span>, <span class="string">&#x27;x/lr1&#x27;</span>, <span class="string">&#x27;x/lr2&#x27;</span>]  <span class="comment"># params</span></span><br><span class="line">            <span class="keyword">for</span> x, tag <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">list</span>(mloss[:-<span class="number">1</span>]) + <span class="built_in">list</span>(results) + lr, tags):</span><br><span class="line">                <span class="keyword">if</span> tb_writer:</span><br><span class="line">                    tb_writer.add_scalar(tag, x, epoch)  <span class="comment"># tensorboard</span></span><br><span class="line">                <span class="keyword">if</span> wandb:</span><br><span class="line">                    wandb.log(&#123;tag: x&#125;)  <span class="comment"># W&amp;B</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update best mAP</span></span><br><span class="line">            fi = fitness(np.array(results).reshape(<span class="number">1</span>, -<span class="number">1</span>))  <span class="comment"># weighted combination of [P, R, mAP@.5, mAP@.5-.95]</span></span><br><span class="line">            <span class="keyword">if</span> fi &gt; best_fitness:</span><br><span class="line">                best_fitness = fi</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Save model</span></span><br><span class="line">            save = (<span class="keyword">not</span> opt.nosave) <span class="keyword">or</span> (final_epoch <span class="keyword">and</span> <span class="keyword">not</span> opt.evolve)</span><br><span class="line">            <span class="keyword">if</span> save:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(results_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># create checkpoint</span></span><br><span class="line">                    ckpt = &#123;<span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">                            <span class="string">&#x27;best_fitness&#x27;</span>: best_fitness,</span><br><span class="line">                            <span class="string">&#x27;training_results&#x27;</span>: f.read(),</span><br><span class="line">                            <span class="string">&#x27;model&#x27;</span>: ema.ema,</span><br><span class="line">                            <span class="string">&#x27;optimizer&#x27;</span>: <span class="literal">None</span> <span class="keyword">if</span> final_epoch <span class="keyword">else</span> optimizer.state_dict(),</span><br><span class="line">                            <span class="string">&#x27;wandb_id&#x27;</span>: wandb_run.<span class="built_in">id</span> <span class="keyword">if</span> wandb <span class="keyword">else</span> <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Save last, best and delete</span></span><br><span class="line">                torch.save(ckpt, last)</span><br><span class="line">                <span class="keyword">if</span> best_fitness == fi:</span><br><span class="line">                    torch.save(ckpt, best)</span><br><span class="line">                <span class="keyword">del</span> ckpt</span><br><span class="line">        <span class="comment"># end epoch ----------------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># end training</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">        <span class="comment"># Strip optimizers</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            strip_optimizer 函数将 optimizer 从 ckpt 去除</span></span><br><span class="line"><span class="string">            并且对模型进行 model.half() float32 --&gt; float16</span></span><br><span class="line"><span class="string">            可以减少模型大小，提高前向推理速度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        final = best <span class="keyword">if</span> best.exists() <span class="keyword">else</span> last  <span class="comment"># final model</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> [last, best]:</span><br><span class="line">            <span class="keyword">if</span> f.exists():</span><br><span class="line">                strip_optimizer(f)  <span class="comment"># strip optimizers</span></span><br><span class="line">        <span class="keyword">if</span> opt.bucket:</span><br><span class="line">            os.system(<span class="string">f&#x27;gsutil cp <span class="subst">&#123;final&#125;</span> gs://<span class="subst">&#123;opt.bucket&#125;</span>/weights&#x27;</span>)  <span class="comment"># upload</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plots</span></span><br><span class="line">        <span class="keyword">if</span> plots:</span><br><span class="line">            plot_results(save_dir=save_dir)  <span class="comment"># save as results.png</span></span><br><span class="line">            <span class="keyword">if</span> wandb:</span><br><span class="line">                files = [<span class="string">&#x27;results.png&#x27;</span>, <span class="string">&#x27;precision_recall_curve.png&#x27;</span>, <span class="string">&#x27;confusion_matrix.png&#x27;</span>]</span><br><span class="line">                wandb.log(&#123;<span class="string">&quot;Results&quot;</span>: [wandb.Image(<span class="built_in">str</span>(save_dir / f), caption=f) <span class="keyword">for</span> f <span class="keyword">in</span> files</span><br><span class="line">                                       <span class="keyword">if</span> (save_dir / f).exists()]&#125;)</span><br><span class="line">                <span class="keyword">if</span> opt.log_artifacts:</span><br><span class="line">                    wandb.log_artifact(artifact_or_path=<span class="built_in">str</span>(final), <span class="built_in">type</span>=<span class="string">&#x27;model&#x27;</span>, name=save_dir.stem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Test best.pt</span></span><br><span class="line">        logger.info(<span class="string">&#x27;%g epochs completed in %.3f hours.\n&#x27;</span> % (epoch - start_epoch + <span class="number">1</span>, (time.time() - t0) / <span class="number">3600</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> opt.data.endswith(<span class="string">&#x27;coco.yaml&#x27;</span>) <span class="keyword">and</span> nc == <span class="number">80</span>:  <span class="comment"># if COCO</span></span><br><span class="line">            <span class="keyword">for</span> conf, iou, save_json <span class="keyword">in</span> ([<span class="number">0.25</span>, <span class="number">0.45</span>, <span class="literal">False</span>], [<span class="number">0.001</span>, <span class="number">0.65</span>, <span class="literal">True</span>]):  <span class="comment"># speed, mAP tests</span></span><br><span class="line">                results, _, _ = test.test(opt.data,</span><br><span class="line">                                          batch_size=total_batch_size,</span><br><span class="line">                                          imgsz=imgsz_test,</span><br><span class="line">                                          conf_thres=conf,</span><br><span class="line">                                          iou_thres=iou,</span><br><span class="line">                                          model=attempt_load(final, device).half(),</span><br><span class="line">                                          single_cls=opt.single_cls,</span><br><span class="line">                                          dataloader=testloader,</span><br><span class="line">                                          save_dir=save_dir,</span><br><span class="line">                                          save_json=save_json,</span><br><span class="line">                                          plots=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dist.destroy_process_group() <span class="comment"># 释放显存</span></span><br><span class="line"></span><br><span class="line">    wandb.run.finish() <span class="keyword">if</span> wandb <span class="keyword">and</span> wandb.run <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    torch.cuda.empty_cache()</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--weights&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;weights/yolov5s.pt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;initial weights path&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cfg&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;models/yolov5s.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;model.yaml path&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;data/coco128.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;data.yaml path&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--hyp&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;data/hyp.scratch.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;hyperparameters path&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">2</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">8</span>, <span class="built_in">help</span>=<span class="string">&#x27;total batch size for all GPUs&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--img-size&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=[<span class="number">640</span>, <span class="number">640</span>], <span class="built_in">help</span>=<span class="string">&#x27;[train, test] image sizes&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--rect&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;rectangular training&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--resume&#x27;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, const=<span class="literal">True</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;resume most recent training&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--nosave&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;only save final checkpoint&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--notest&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;only test final epoch&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--noautoanchor&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;disable autoanchor check&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--evolve&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;evolve hyperparameters&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--bucket&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;gsutil bucket&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cache-images&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;cache images for faster training&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--image-weights&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;use weighted image selection for training&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--device&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;cuda device, i.e. 0 or 0,1,2,3 or cpu&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--multi-scale&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;vary img-size +/- 50%%&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--single-cls&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;train multi-class data as single-class&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--adam&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;use torch.optim.Adam() optimizer&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--sync-bn&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;use SyncBatchNorm, only available in DDP mode&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--local_rank&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=-<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">&#x27;DDP parameter, do not modify&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--log-imgs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>, <span class="built_in">help</span>=<span class="string">&#x27;number of images for W&amp;B logging, max 100&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--log-artifacts&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;log artifacts, i.e. final trained model&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--workers&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">8</span>, <span class="built_in">help</span>=<span class="string">&#x27;maximum number of dataloader workers&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--project&#x27;</span>, default=<span class="string">&#x27;runs/train&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save to project/name&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--name&#x27;</span>, default=<span class="string">&#x27;exp&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save to project/name&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--exist-ok&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;existing project/name ok, do not increment&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--quad&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;quad dataloader&#x27;</span>)</span><br><span class="line">    opt = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set DDP variables 设置 DDP 模式的参数</span></span><br><span class="line">    opt.world_size = <span class="built_in">int</span>(os.environ[<span class="string">&#x27;WORLD_SIZE&#x27;</span>]) <span class="keyword">if</span> <span class="string">&#x27;WORLD_SIZE&#x27;</span> <span class="keyword">in</span> os.environ <span class="keyword">else</span> <span class="number">1</span> <span class="comment"># 全局进程个数</span></span><br><span class="line">    opt.global_rank = <span class="built_in">int</span>(os.environ[<span class="string">&#x27;RANK&#x27;</span>]) <span class="keyword">if</span> <span class="string">&#x27;RANK&#x27;</span> <span class="keyword">in</span> os.environ <span class="keyword">else</span> -<span class="number">1</span> <span class="comment"># 进程编号</span></span><br><span class="line">    set_logging(opt.global_rank)</span><br><span class="line">    <span class="keyword">if</span> opt.global_rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">        check_git_status()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Resume</span></span><br><span class="line">    <span class="keyword">if</span> opt.resume:  <span class="comment"># resume an interrupted run 是否是接着上次训练</span></span><br><span class="line">        ckpt = opt.resume <span class="keyword">if</span> <span class="built_in">isinstance</span>(opt.resume, <span class="built_in">str</span>) <span class="keyword">else</span> get_latest_run()  <span class="comment"># specified or most recent path</span></span><br><span class="line">        <span class="keyword">assert</span> os.path.isfile(ckpt), <span class="string">&#x27;ERROR: --resume checkpoint does not exist&#x27;</span></span><br><span class="line">        apriori = opt.global_rank, opt.local_rank</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(Path(ckpt).parent.parent / <span class="string">&#x27;opt.yaml&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            opt = argparse.Namespace(**yaml.load(f, Loader=yaml.FullLoader))  <span class="comment"># replace</span></span><br><span class="line">        opt.cfg, opt.weights, opt.resume, opt.global_rank, opt.local_rank = <span class="string">&#x27;&#x27;</span>, ckpt, <span class="literal">True</span>, *apriori  <span class="comment"># reinstate</span></span><br><span class="line">        logger.info(<span class="string">&#x27;Resuming training from %s&#x27;</span> % ckpt)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># opt.hyp = opt.hyp or (&#x27;hyp.finetune.yaml&#x27; if opt.weights else &#x27;hyp.scratch.yaml&#x27;)</span></span><br><span class="line">        <span class="comment"># 获取配置文件信息并检查</span></span><br><span class="line">        opt.data, opt.cfg, opt.hyp = check_file(opt.data), check_file(opt.cfg), check_file(opt.hyp)  <span class="comment"># check files</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(opt.cfg) <span class="keyword">or</span> <span class="built_in">len</span>(opt.weights), <span class="string">&#x27;either --cfg or --weights must be specified&#x27;</span></span><br><span class="line">        opt.img_size.extend([opt.img_size[-<span class="number">1</span>]] * (<span class="number">2</span> - <span class="built_in">len</span>(opt.img_size)))  <span class="comment"># extend to 2 sizes (train, test)</span></span><br><span class="line">        opt.name = <span class="string">&#x27;evolve&#x27;</span> <span class="keyword">if</span> opt.evolve <span class="keyword">else</span> opt.name</span><br><span class="line">        <span class="comment"># 生成保存文件输出目录</span></span><br><span class="line">        opt.save_dir = increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok | opt.evolve)  <span class="comment"># increment run</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># DDP mode</span></span><br><span class="line">    opt.total_batch_size = opt.batch_size</span><br><span class="line">    device = select_device(opt.device, batch_size=opt.batch_size)</span><br><span class="line">    <span class="keyword">if</span> opt.local_rank != -<span class="number">1</span>: <span class="comment"># 多 GPU 情况</span></span><br><span class="line">        <span class="keyword">assert</span> torch.cuda.device_count() &gt; opt.local_rank</span><br><span class="line">        torch.cuda.set_device(opt.local_rank)</span><br><span class="line">        device = torch.device(<span class="string">&#x27;cuda&#x27;</span>, opt.local_rank)</span><br><span class="line">        dist.init_process_group(backend=<span class="string">&#x27;nccl&#x27;</span>, init_method=<span class="string">&#x27;env://&#x27;</span>)  <span class="comment"># distributed backend</span></span><br><span class="line">        <span class="keyword">assert</span> opt.batch_size % opt.world_size == <span class="number">0</span>, <span class="string">&#x27;--batch-size must be multiple of CUDA device count&#x27;</span></span><br><span class="line">        opt.batch_size = opt.total_batch_size // opt.world_size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Hyperparameters</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(opt.hyp) <span class="keyword">as</span> f:</span><br><span class="line">        hyp = yaml.load(f, Loader=yaml.FullLoader)  <span class="comment"># load hyps 加载超参数配置文件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;box&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> hyp:</span><br><span class="line">            warn(<span class="string">&#x27;Compatibility: %s missing &quot;box&quot; which was renamed from &quot;giou&quot; in %s&#x27;</span> %</span><br><span class="line">                 (opt.hyp, <span class="string">&#x27;https://github.com/ultralytics/yolov5/pull/1120&#x27;</span>))</span><br><span class="line">            hyp[<span class="string">&#x27;box&#x27;</span>] = hyp.pop(<span class="string">&#x27;giou&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train</span></span><br><span class="line">    logger.info(opt) <span class="comment"># 打印 opt 参数信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> opt.evolve:</span><br><span class="line">        tb_writer = <span class="literal">None</span>  <span class="comment"># init loggers</span></span><br><span class="line">        <span class="keyword">if</span> opt.global_rank <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>]:</span><br><span class="line">            logger.info(<span class="string">f&#x27;Start Tensorboard with &quot;tensorboard --logdir <span class="subst">&#123;opt.project&#125;</span>&quot;, view at http://localhost:6006/&#x27;</span>)</span><br><span class="line">            tb_writer = SummaryWriter(opt.save_dir)  <span class="comment"># Tensorboard</span></span><br><span class="line">        train(hyp, opt, device, tb_writer, wandb)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Evolve hyperparameters (optional)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Hyperparameter evolution metadata (mutation scale 0-1, lower_limit, upper_limit)</span></span><br><span class="line">        meta = &#123;<span class="string">&#x27;lr0&#x27;</span>: (<span class="number">1</span>, <span class="number">1e-5</span>, <span class="number">1e-1</span>),  <span class="comment"># initial learning rate (SGD=1E-2, Adam=1E-3)</span></span><br><span class="line">                <span class="string">&#x27;lrf&#x27;</span>: (<span class="number">1</span>, <span class="number">0.01</span>, <span class="number">1.0</span>),  <span class="comment"># final OneCycleLR learning rate (lr0 * lrf)</span></span><br><span class="line">                <span class="string">&#x27;momentum&#x27;</span>: (<span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.98</span>),  <span class="comment"># SGD momentum/Adam beta1</span></span><br><span class="line">                <span class="string">&#x27;weight_decay&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.001</span>),  <span class="comment"># optimizer weight decay</span></span><br><span class="line">                <span class="string">&#x27;warmup_epochs&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">5.0</span>),  <span class="comment"># warmup epochs (fractions ok)</span></span><br><span class="line">                <span class="string">&#x27;warmup_momentum&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.95</span>),  <span class="comment"># warmup initial momentum</span></span><br><span class="line">                <span class="string">&#x27;warmup_bias_lr&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.2</span>),  <span class="comment"># warmup initial bias lr</span></span><br><span class="line">                <span class="string">&#x27;box&#x27;</span>: (<span class="number">1</span>, <span class="number">0.02</span>, <span class="number">0.2</span>),  <span class="comment"># box loss gain</span></span><br><span class="line">                <span class="string">&#x27;cls&#x27;</span>: (<span class="number">1</span>, <span class="number">0.2</span>, <span class="number">4.0</span>),  <span class="comment"># cls loss gain</span></span><br><span class="line">                <span class="string">&#x27;cls_pw&#x27;</span>: (<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">2.0</span>),  <span class="comment"># cls BCELoss positive_weight</span></span><br><span class="line">                <span class="string">&#x27;obj&#x27;</span>: (<span class="number">1</span>, <span class="number">0.2</span>, <span class="number">4.0</span>),  <span class="comment"># obj loss gain (scale with pixels)</span></span><br><span class="line">                <span class="string">&#x27;obj_pw&#x27;</span>: (<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">2.0</span>),  <span class="comment"># obj BCELoss positive_weight</span></span><br><span class="line">                <span class="string">&#x27;iou_t&#x27;</span>: (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.7</span>),  <span class="comment"># IoU training threshold</span></span><br><span class="line">                <span class="string">&#x27;anchor_t&#x27;</span>: (<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">8.0</span>),  <span class="comment"># anchor-multiple threshold</span></span><br><span class="line">                <span class="string">&#x27;anchors&#x27;</span>: (<span class="number">2</span>, <span class="number">2.0</span>, <span class="number">10.0</span>),  <span class="comment"># anchors per output grid (0 to ignore)</span></span><br><span class="line">                <span class="string">&#x27;fl_gamma&#x27;</span>: (<span class="number">0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>),  <span class="comment"># focal loss gamma (efficientDet default gamma=1.5)</span></span><br><span class="line">                <span class="string">&#x27;hsv_h&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.1</span>),  <span class="comment"># image HSV-Hue augmentation (fraction)</span></span><br><span class="line">                <span class="string">&#x27;hsv_s&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.9</span>),  <span class="comment"># image HSV-Saturation augmentation (fraction)</span></span><br><span class="line">                <span class="string">&#x27;hsv_v&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.9</span>),  <span class="comment"># image HSV-Value augmentation (fraction)</span></span><br><span class="line">                <span class="string">&#x27;degrees&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">45.0</span>),  <span class="comment"># image rotation (+/- deg)</span></span><br><span class="line">                <span class="string">&#x27;translate&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.9</span>),  <span class="comment"># image translation (+/- fraction)</span></span><br><span class="line">                <span class="string">&#x27;scale&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">0.9</span>),  <span class="comment"># image scale (+/- gain)</span></span><br><span class="line">                <span class="string">&#x27;shear&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">10.0</span>),  <span class="comment"># image shear (+/- deg)</span></span><br><span class="line">                <span class="string">&#x27;perspective&#x27;</span>: (<span class="number">0</span>, <span class="number">0.0</span>, <span class="number">0.001</span>),  <span class="comment"># image perspective (+/- fraction), range 0-0.001</span></span><br><span class="line">                <span class="string">&#x27;flipud&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">1.0</span>),  <span class="comment"># image flip up-down (probability)</span></span><br><span class="line">                <span class="string">&#x27;fliplr&#x27;</span>: (<span class="number">0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>),  <span class="comment"># image flip left-right (probability)</span></span><br><span class="line">                <span class="string">&#x27;mosaic&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">1.0</span>),  <span class="comment"># image mixup (probability)</span></span><br><span class="line">                <span class="string">&#x27;mixup&#x27;</span>: (<span class="number">1</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)&#125;  <span class="comment"># image mixup (probability)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> opt.local_rank == -<span class="number">1</span>, <span class="string">&#x27;DDP mode not implemented for --evolve&#x27;</span></span><br><span class="line">        opt.notest, opt.nosave = <span class="literal">True</span>, <span class="literal">True</span>  <span class="comment"># only test/save final epoch</span></span><br><span class="line">        <span class="comment"># ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices</span></span><br><span class="line">        yaml_file = Path(opt.save_dir) / <span class="string">&#x27;hyp_evolved.yaml&#x27;</span>  <span class="comment"># save best result here</span></span><br><span class="line">        <span class="keyword">if</span> opt.bucket:</span><br><span class="line">            os.system(<span class="string">&#x27;gsutil cp gs://%s/evolve.txt .&#x27;</span> % opt.bucket)  <span class="comment"># download evolve.txt if exists</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>):  <span class="comment"># generations to evolve</span></span><br><span class="line">            <span class="keyword">if</span> Path(<span class="string">&#x27;evolve.txt&#x27;</span>).exists():  <span class="comment"># if evolve.txt exists: select best hyps and mutate</span></span><br><span class="line">                <span class="comment"># Select parent(s)</span></span><br><span class="line">                parent = <span class="string">&#x27;single&#x27;</span>  <span class="comment"># parent selection method: &#x27;single&#x27; or &#x27;weighted&#x27;</span></span><br><span class="line">                x = np.loadtxt(<span class="string">&#x27;evolve.txt&#x27;</span>, ndmin=<span class="number">2</span>)</span><br><span class="line">                n = <span class="built_in">min</span>(<span class="number">5</span>, <span class="built_in">len</span>(x))  <span class="comment"># number of previous results to consider</span></span><br><span class="line">                x = x[np.argsort(-fitness(x))][:n]  <span class="comment"># top n mutations</span></span><br><span class="line">                w = fitness(x) - fitness(x).<span class="built_in">min</span>()  <span class="comment"># weights</span></span><br><span class="line">                <span class="keyword">if</span> parent == <span class="string">&#x27;single&#x27;</span> <span class="keyword">or</span> <span class="built_in">len</span>(x) == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># x = x[random.randint(0, n - 1)]  # random selection</span></span><br><span class="line">                    x = x[random.choices(<span class="built_in">range</span>(n), weights=w)[<span class="number">0</span>]]  <span class="comment"># weighted selection</span></span><br><span class="line">                <span class="keyword">elif</span> parent == <span class="string">&#x27;weighted&#x27;</span>:</span><br><span class="line">                    x = (x * w.reshape(n, <span class="number">1</span>)).<span class="built_in">sum</span>(<span class="number">0</span>) / w.<span class="built_in">sum</span>()  <span class="comment"># weighted combination</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Mutate</span></span><br><span class="line">                mp, s = <span class="number">0.8</span>, <span class="number">0.2</span>  <span class="comment"># mutation probability, sigma</span></span><br><span class="line">                npr = np.random</span><br><span class="line">                npr.seed(<span class="built_in">int</span>(time.time()))</span><br><span class="line">                g = np.array([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> meta.values()])  <span class="comment"># gains 0-1</span></span><br><span class="line">                ng = <span class="built_in">len</span>(meta)</span><br><span class="line">                v = np.ones(ng)</span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">all</span>(v == <span class="number">1</span>):  <span class="comment"># mutate until a change occurs (prevent duplicates)</span></span><br><span class="line">                    v = (g * (npr.random(ng) &lt; mp) * npr.randn(ng) * npr.random() * s + <span class="number">1</span>).clip(<span class="number">0.3</span>, <span class="number">3.0</span>)</span><br><span class="line">                <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(hyp.keys()):  <span class="comment"># plt.hist(v.ravel(), 300)</span></span><br><span class="line">                    hyp[k] = <span class="built_in">float</span>(x[i + <span class="number">7</span>] * v[i])  <span class="comment"># mutate</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Constrain to limits</span></span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> meta.items():</span><br><span class="line">                hyp[k] = <span class="built_in">max</span>(hyp[k], v[<span class="number">1</span>])  <span class="comment"># lower limit</span></span><br><span class="line">                hyp[k] = <span class="built_in">min</span>(hyp[k], v[<span class="number">2</span>])  <span class="comment"># upper limit</span></span><br><span class="line">                hyp[k] = <span class="built_in">round</span>(hyp[k], <span class="number">5</span>)  <span class="comment"># significant digits</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Train mutation</span></span><br><span class="line">            results = train(hyp.copy(), opt, device, wandb=wandb)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Write mutation results</span></span><br><span class="line">            print_mutation(hyp.copy(), results, yaml_file, opt.bucket)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot results</span></span><br><span class="line">        plot_evolution(yaml_file)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Hyperparameter evolution complete. Best results saved as: <span class="subst">&#123;yaml_file&#125;</span>\n&#x27;</span></span><br><span class="line">              <span class="string">f&#x27;Command to train a new model with these hyperparameters: $ python train.py --hyp <span class="subst">&#123;yaml_file&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="yolov5s.yaml">yolov5s.yaml</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parameters</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">80</span>  <span class="comment"># number of classes</span></span><br><span class="line"><span class="attr">depth_multiple:</span> <span class="number">0.33</span>  <span class="comment"># model depth multiple 控制模型深度</span></span><br><span class="line"><span class="attr">width_multiple:</span> <span class="number">0.50</span>  <span class="comment"># layer channel multiple 控制模型宽度，卷积核数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># anchors</span></span><br><span class="line"><span class="attr">anchors:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  <span class="comment"># P3/8         P3,经过了8倍下采样</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  <span class="comment"># P4/16       P4,经过了16倍下采样</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  <span class="comment"># P5/32   P5,经过了32倍下采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># YOLOv5 backbone</span></span><br><span class="line"><span class="attr">backbone:</span></span><br><span class="line">  <span class="comment"># [from, number, module, args]</span></span><br><span class="line">  <span class="comment"># from, 表示当前模块输入来自哪一层，-1代表来自上一次层</span></span><br><span class="line">  <span class="comment"># number，本模块重复次数</span></span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Focus</span>, [<span class="number">64</span>, <span class="number">3</span>]],  <span class="comment"># 0-P1/2</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]],  <span class="comment"># 1-P2/4   128个卷积核，卷积核大小为3*3，步长为2</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, <span class="string">C3</span>, [<span class="number">128</span>]], </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],  <span class="comment"># 3-P3/8</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, <span class="string">C3</span>, [<span class="number">256</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],  <span class="comment"># 5-P4/16</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, <span class="string">C3</span>, [<span class="number">512</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]],  <span class="comment"># 7-P5/32</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">SPP</span>, [<span class="number">1024</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>]]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, <span class="string">C3</span>, [<span class="number">1024</span>, <span class="literal">False</span>]],  <span class="comment"># 9</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># YOLOv5 head</span></span><br><span class="line"><span class="comment"># head 部分包含了 PANet + Detect 部分</span></span><br><span class="line"><span class="attr">head:</span></span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">nn.Upsample</span>, [<span class="string">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, <span class="string">Concat</span>, [<span class="number">1</span>]],  <span class="comment"># cat backbone P4</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, <span class="string">C3</span>, [<span class="number">512</span>, <span class="literal">False</span>]],  <span class="comment"># 13</span></span><br><span class="line"></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">nn.Upsample</span>, [<span class="string">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="string">Concat</span>, [<span class="number">1</span>]],  <span class="comment"># cat backbone P3</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, <span class="string">C3</span>, [<span class="number">256</span>, <span class="literal">False</span>]],  <span class="comment"># 17 (P3/8-small)  </span></span><br><span class="line"></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, <span class="string">Concat</span>, [<span class="number">1</span>]],  <span class="comment"># cat head P4</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, <span class="string">C3</span>, [<span class="number">512</span>, <span class="literal">False</span>]],  <span class="comment"># 20 (P4/16-medium)</span></span><br><span class="line"></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, <span class="string">Concat</span>, [<span class="number">1</span>]],  <span class="comment"># cat head P5</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, <span class="string">C3</span>, [<span class="number">1024</span>, <span class="literal">False</span>]],  <span class="comment"># 23 (P5/32-large)</span></span><br><span class="line"></span><br><span class="line">   [[<span class="number">17</span>, <span class="number">20</span>, <span class="number">23</span>], <span class="number">1</span>, <span class="string">Detect</span>, [<span class="string">nc</span>, <span class="string">anchors</span>]],  <span class="comment"># Detect(P3, P4, P5)</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>YOLO V5</category>
      </categories>
      <tags>
        <tag>YOLO V5-4.0</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualenv</title>
    <url>/configuration/virtualenv/</url>
    <content><![CDATA[<center>
virtualenv 配置和换源
</center>
<span id="more"></span>
<h4 id="virtualenv">virtualenv</h4>
<p>virtualenv 可创建虚拟环境，用于管理不同 python 项目所需的依赖项，而项目彼此之间不相互干扰。</p>
<ul>
<li>安装 virtualenv <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure></li>
<li>创建虚拟环境 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkdir env     <span class="comment"># 创建文件夹</span></span><br><span class="line">virtualenv first-env</span><br></pre></td></tr></table></figure></li>
<li>也可以创建指定 python 编译器的环境 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virtualenv -p path/python.exe venv</span><br></pre></td></tr></table></figure></li>
<li>激活环境 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd ../Scripts</span><br><span class="line">activate</span><br></pre></td></tr></table></figure></li>
<li>停止激活环境 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注：如果是使用 vscode 作为 python 开发环境的话，使用 virtualenv 创建的 python 解释器会出现以下错误：</p>
<blockquote>
<p>无法加载 ...ps1，因为在此系统上禁止运行此脚本</p>
</blockquote>
<p>解决办法是：win + x, 选择 <code>Windows Powershell(管理员)</code>，输入 <code>set-executionpolicy remotesigned</code>，再输入 <code>y</code> 确认。</p>
<h4 id="pip-换源">pip 换源</h4>
<ul>
<li>Linux: 修改 <code>~/.pip/pip.conf</code> 文件(没有则创建一个), 内容如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li>
<li>windows:
<ol type="1">
<li>在 user 目录中创建一个 pip 目录, 如 <code>C:\Users\TLDX\pip</code>, 在 pip 目录下新建 <code>pip.ini</code>, 内容如下 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure></li>
<li>直接命令行输入： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url http://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>configuration</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda-cudnn-pytorch 安装教程</title>
    <url>/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<center>
cuda-cudnn-pytorch 安装教程
</center>
<span id="more"></span>
<h3 id="cuda-安装">CUDA 安装</h3>
<ol type="1">
<li>使用 <code>nvidia-smi</code> 查看自己的 nvidia GPU CUDA 驱动版本</li>
</ol>
<p><img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_driver_version.png"></p>
<ol start="2" type="1">
<li>去官网下载 CUDA 包。</li>
</ol>
<p>https://developer.nvidia.com/cuda-toolkit-archive <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_download.png" alt="cuda_download"> 选择本地安装 <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_download_2.png"> 注意，下载的CUDA包的版本号不能大于自己GPU CUDA的版本。这是官方给的建议。 https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</p>
<p><img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_suggestion.png"></p>
<ol start="3" type="1">
<li>安装 CUDA <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_install_1.png"> 我们进行自定义安装。自定义安装这里可以进行一些设置，否则有可能会导致安装失败，首先组件这里取勾GeForce Experience。 <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_install_2.jpg"> 然后， 我这里安装的时候，必须Visual Studio Integration也需要取消勾选。 <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_install_3.jpg"> 点开Driver comonents，Display Driver这一行，前面显示的是Cuda本身包含的驱动版本是411.31 如果你电脑目前安装的驱动版本号新于Cuda本身自带的驱动版本号，那一定要把这个勾去掉。否则会安装失败(相同或小于的话，就不用去取勾了) <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cuda_install_4.jpg"></li>
</ol>
<p>安装完成后，使用 <code>nvcc -V</code> 命令测试是否安装成功 <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/nvcc.png"></p>
<h3 id="cudnn-安装">cudnn 安装</h3>
<p>cudnn 需要登录下载(科学上网)。 1. 官网下载：https://developer.nvidia.com/rdp/cudnn-archive。 下载的时候尽量与 CUDA 版本对应。 <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cudnn_download.png"></p>
<ol type="1">
<li>解压文件夹，将解压后的文件夹下的文件拷贝到cuda安装目录下，与之相对应的文件夹下。 <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/cudnn_install.png"></li>
<li>添加系统环境变量 <img src="/configuration/cuda-cudnn-pytorch-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/path_variable.png"></li>
</ol>
<h3 id="pytorch-安装">PyTorch 安装</h3>
<ol type="1">
<li><p>官网下载，找到自己对应的 cuda-pytorch</p>
<p>https://pytorch.org/get-started/previous-versions/</p></li>
<li><p>使用 pip 或 conda 安装 pytorch。安装的时候推荐使用虚拟环境，以避免依赖包冲突。</p></li>
</ol>
]]></content>
      <categories>
        <category>configuration</category>
      </categories>
  </entry>
  <entry>
    <title>vscode cpp-jupyter configuration</title>
    <url>/configuration/vscode-cpp-jupyter-configuration/</url>
    <content><![CDATA[<center>
vscode c++和jupyter 配置方法
</center>
<span id="more"></span>
<h3 id="c">c++</h3>
<ol type="1">
<li><p>在 vscode 中安装 c/c++ 插件</p></li>
<li><p>由于 vscode 只是一款代码编辑器，并不提供编译器的功能，因此我们还需要下载编译器。这里我下载了 <a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-W64</a>，选择的版本是 <code>MinGW-W64 GCC-8.1.0</code>，使用 <code>x86_64-win32-seh</code>。</p></li>
<li><p>我们按照如下的规则创建文件目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++project</span><br><span class="line">├─ .vscode</span><br><span class="line">│  ├─ launch.json</span><br><span class="line">│  └─ tasks.json</span><br><span class="line">├─ bin</span><br><span class="line">│  └─ cpp.exe</span><br><span class="line">└─ test.cpp</span><br></pre></td></tr></table></figure> .vscode 中的文件即是配置 c++ 文件，需要我们配置，其中 tasks.json 是编译配置文件，launch.json 是调试配置文件。bin 中存放的是编译生成的可执行文件。</p></li>
<li><p>tasks.json 文件配置方法如下 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">     &#123;<span class="comment">//这个大括号里是‘构建（build）’任务</span></span><br><span class="line">         <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//任务名称，可以更改，不过不建议改</span></span><br><span class="line">         <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>, <span class="comment">//任务类型，process是vsc把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍</span></span><br><span class="line">         <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>, <span class="comment">//编译命令，这里是g++，编译c的话换成gcc</span></span><br><span class="line">         <span class="attr">&quot;args&quot;</span>: [    <span class="comment">//方括号里是传给g++命令的一系列参数，用于实现一些功能</span></span><br><span class="line">             <span class="string">&quot;$&#123;file&#125;&quot;</span>, <span class="comment">//指定要编译的是当前文件</span></span><br><span class="line">             <span class="string">&quot;-o&quot;</span>, <span class="comment">//指定输出文件的路径和名称</span></span><br><span class="line">             <span class="string">&quot;bin\\cpp.exe&quot;</span>, <span class="comment">//承接上一步的-o，让可执行文件输出到源码文件所在的文件夹下的bin文件夹内，并且让它的名字和源码文件相同</span></span><br><span class="line">             <span class="string">&quot;-g&quot;</span>, <span class="comment">//生成和调试有关的信息</span></span><br><span class="line">             <span class="string">&quot;-Wall&quot;</span>, <span class="comment">// 开启额外警告</span></span><br><span class="line">             <span class="string">&quot;-static-libgcc&quot;</span>,  <span class="comment">// 静态链接libgcc</span></span><br><span class="line">             <span class="string">&quot;-fexec-charset=GBK&quot;</span>, <span class="comment">// 生成的程序使用GBK编码，不加这一条会导致Win下输出中文乱码</span></span><br><span class="line">             <span class="string">&quot;-std=c++11&quot;</span>, <span class="comment">// 语言标准，可根据自己的需要进行修改，写c++要换成c++的语言标准，比如c++11</span></span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">&quot;group&quot;</span>: &#123;  <span class="comment">//group表示‘组’，我们可以有很多的task，然后把他们放在一个‘组’里</span></span><br><span class="line">             <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,<span class="comment">//表示这一组任务类型是构建</span></span><br><span class="line">             <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span><span class="comment">//表示这个任务是当前这组任务中的默认任务</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;presentation&quot;</span>: &#123; <span class="comment">//执行这个任务时的一些其他设定</span></span><br><span class="line">             <span class="attr">&quot;echo&quot;</span>: <span class="literal">true</span>,<span class="comment">//表示在执行任务时在终端要有输出</span></span><br><span class="line">             <span class="attr">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>, <span class="comment">//执行任务时是否跳转到终端面板，可以为always，silent，never</span></span><br><span class="line">             <span class="attr">&quot;focus&quot;</span>: <span class="literal">false</span>, <span class="comment">//设为true后可以使执行task时焦点聚集在终端，但对编译来说，设为true没有意义，因为运行的时候才涉及到输入</span></span><br><span class="line">             <span class="attr">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span> <span class="comment">//每次执行这个task时都新建一个终端面板，也可以设置为shared，共用一个面板，不过那样会出现‘任务将被终端重用’的提示，比较烦人</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;problemMatcher&quot;</span>: <span class="string">&quot;$gcc&quot;</span> <span class="comment">//捕捉编译时编译器在终端里显示的报错信息，将其显示在vscode的‘问题’面板里</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;<span class="comment">//这个大括号里是‘运行(run)’任务，一些设置与上面的构建任务性质相同</span></span><br><span class="line">         <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;run&quot;</span>, </span><br><span class="line">         <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>, </span><br><span class="line">         <span class="attr">&quot;dependsOn&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//任务依赖，因为要运行必须先构建，所以执行这个任务前必须先执行build任务，</span></span><br><span class="line">         <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;bin\\cpp.exe&quot;</span>, <span class="comment">//执行exe文件，只需要指定这个exe文件在哪里就好</span></span><br><span class="line">         <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">             <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">//这一组是‘测试’组，将run任务放在test组里方便我们用快捷键执行</span></span><br><span class="line">             <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;presentation&quot;</span>: &#123;</span><br><span class="line">             <span class="attr">&quot;echo&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">             <span class="attr">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line">             <span class="attr">&quot;focus&quot;</span>: <span class="literal">true</span>, <span class="comment">//这个就设置为true了，运行任务后将焦点聚集到终端，方便进行输入</span></span><br><span class="line">             <span class="attr">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">         ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> 其中大部分都不需要修改，需要注意的几点是：</p>
<p>build 任务中：</p>
<ul>
<li><code>command</code>：选择是编译 c++ 文件还是 c 文件</li>
<li><code>args</code>：执行命令的参数，主要有编译的文件名，文件输出路径，语言标准等</li>
</ul>
<p>run 任务中：</p>
<ul>
<li><code>command</code>：指定可执行文件路径</li>
</ul></li>
<li><p>launch.json 的配置方法如下 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">     </span><br><span class="line">     &#123;<span class="comment">//这个大括号里是我们的‘调试(Debug)’配置</span></span><br><span class="line">         <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debug&quot;</span>, <span class="comment">// 配置名称</span></span><br><span class="line">         <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>, <span class="comment">// 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg</span></span><br><span class="line">         <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>, <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">         <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;\\bin\\cpp.exe&quot;</span>, <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">         <span class="attr">&quot;args&quot;</span>: [], <span class="comment">// 程序调试时传递给程序的命令行参数，这里设为空即可</span></span><br><span class="line">         <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>, <span class="comment">// 设为true时程序将暂停在程序入口处，相当于在main上打断点</span></span><br><span class="line">         <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>, <span class="comment">// 调试程序时的工作目录，此处为源码文件所在目录</span></span><br><span class="line">         <span class="attr">&quot;environment&quot;</span>: [], <span class="comment">// 环境变量，这里设为空即可</span></span><br><span class="line">         <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>, <span class="comment">// 为true时使用单独的cmd窗口，跳出小黑框；设为false则是用vscode的内置终端，建议用内置终端</span></span><br><span class="line">         <span class="attr">&quot;internalConsoleOptions&quot;</span>: <span class="string">&quot;neverOpen&quot;</span>, <span class="comment">// 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，新手调试用不到</span></span><br><span class="line">         <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>, <span class="comment">// 指定连接的调试器，gdb是minGW中的调试程序</span></span><br><span class="line">         <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\Program Files\\mingw64\\bin\\gdb.exe&quot;</span>, <span class="comment">// 指定调试器所在路径，如果你的minGW装在别的地方，则要改成你自己的路径，注意间隔是\\</span></span><br><span class="line">         <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span> <span class="comment">// 调试开始前执行的任务，我们在调试前要编译构建。与tasks.json的label相对应，名字要一样</span></span><br><span class="line">     &#125;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> 需要注意的几点是：</p>
<ul>
<li><code>program</code>：将要执行调试的文件路径</li>
<li><code>miDebuggerPath</code>：指定连接的调试器路径(使用之前下载的 MinGW-64 的路径)</li>
</ul></li>
</ol>
<p>以上便是所有的配置信息了，完成之后便可以轻松利用 vscode 编写 c++ 代码并进行调试。</p>
<h3 id="jupyter">jupyter</h3>
<ol type="1">
<li>安装 jupyter 插件</li>
<li>在 python 解释器对应的环境中，使用 pip 或 conda 安装依赖包。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install ipykernel</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>configuration</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>c++</tag>
        <tag>vscode</tag>
        <tag>configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>感知机算法证明</title>
    <url>/Machine-Learning/%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%AE%97%E6%B3%95%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h3 id="问题描述">1. 问题描述</h3>
<p>感知机算法的提出最初被用来解决二分类问题，即给定 <span class="math inline">\(N\)</span> 个样本，其中每个样本都是 <span class="math inline">\(p\)</span> 维的向量。每一个样本属于 <span class="math inline">\(C_1\)</span> 或 <span class="math inline">\(C_2\)</span>。我们的任务是找到一个超平面来将所有样本进行准确分类并且具有较强的泛化能力。 ### 2. 问题数学描述 这里我们将这类问题抽象为数学描述。我们假设 <span class="math inline">\(x_1,x_2,\ldots,x_N\)</span> 是 <span class="math inline">\(p\)</span> 维向量。然后我们将 <span class="math inline">\(\vec{x}_1,\vec{x}_2,...,\vec{x}_N\)</span> 定义为： 如果 <span class="math inline">\(x_i\in C_1\)</span>,则 <span class="math inline">\(\overrightarrow{x_i}=\begin{bmatrix}x_i\\1\end{bmatrix}\)</span>; 如果 <span class="math inline">\(x_i\in C_2\)</span>,则 <span class="math inline">\(\overrightarrow{x_i}=\begin{bmatrix}-x_i\\ -1\end{bmatrix}\)</span> 此时所有向量变成了 <span class="math inline">\(p+1\)</span> 维。这个问题也转变成了寻找一个 <span class="math inline">\(p+1\)</span> 维向量 <span class="math inline">\(\omega\)</span>, 使得对于任何 <span class="math inline">\(i=1,2,\cdots,N\)</span> 都有： <span class="math display">\[\omega^T\overrightarrow{x_i}&gt; 0\]</span></p>
<span id="more"></span>
<!--算法流程图-->
<h3 id="算法流程">3. 算法流程</h3>
<hr>
<p><span class="math display">\[\begin{aligned}
&amp; \textbf{Input: }\overrightarrow{x_1},\overrightarrow{x_2},\ldots,\overrightarrow{x_N}\\
&amp; \textbf{Output: }\omega  \\
&amp; _\textbf{1} \quad \omega=
\begin{bmatrix}
0 \\ 0 \\ \vdots \\ 0   
\end{bmatrix};\\
&amp;_\textbf{2} \quad FLAG=1;\\
&amp;_\textbf{3} \quad \textbf{while }FLAG \textbf{ do}\\
&amp;_\textbf{4} \quad \qquad FLAG=0;\\
&amp;_\textbf{5} \quad \qquad \textbf{for }i=1:N\;\textbf{do}\\
&amp;_\textbf{6} \quad\qquad\qquad \textbf{if }\omega^T\overrightarrow{x_i}\le 0 \textbf{ then}\\
&amp;_\textbf{7} \quad \qquad\qquad\qquad \omega=\omega+\overrightarrow{x_i};\\
&amp;_\textbf{8} \quad \qquad\qquad\qquad FLAG=1;\\
&amp;_\textbf{9} \quad \qquad\qquad \textbf{end}\\
&amp;_\textbf{10} \quad \qquad \textbf{end}\\
&amp;_\textbf{11} \quad \textbf{end}\\
&amp;_\textbf{12} \quad \textbf{return }w;\\
\end{aligned}
\]</span></p>
<hr>
<h3 id="算法收敛性证明">4. 算法收敛性证明</h3>
<p><strong>定理1</strong> 对于所有的 <span class="math inline">\(N\)</span> 个向量 <span class="math inline">\(\overrightarrow{x_1},\overrightarrow{x_2},\ldots,\overrightarrow{x_N}\)</span>，如果存在一个向量 <span class="math inline">\(\omega_{opt}\)</span> 使得 <span class="math inline">\(\omega_{opt}^T\overrightarrow{x_i}&gt;0\)</span> 对于所有的 <span class="math inline">\(i={1,2,\ldots,N}\)</span> 都成立，则 <strong>3</strong> 中描述的算法一定能够找到一个 <span class="math inline">\(\omega\)</span>，使得 <span class="math inline">\(\omega_{opt}^T\overrightarrow{x_i}&gt;0\)</span> 对于所有 <span class="math inline">\(i={1,2,\ldots,N}\)</span> 都成立。且算法的收敛性不取决于 <span class="math inline">\(\omega\)</span> 的初值选择。 <strong>证明</strong> 我们可以假设 <span class="math inline">\(\lVert \omega_{opt} \Vert=1\)</span>。因为对于找到的超平面 <span class="math inline">\(\omega_{opt}\)</span>，我们总可以乘以一个系数，使得<span class="math inline">\(\omega_{opt}\)</span> 模长为1. 我们记<span class="math inline">\(\omega(k)\)</span> 为<span class="math inline">\(\omega\)</span> 的第 <span class="math inline">\(k\)</span> 次迭代值。然后我们有： 1. 如果对于所有的 <span class="math inline">\(i={1,2,\ldots,N} \omega(k)^T\overrightarrow{x_i}&gt;0\)</span> 都成立，则算法直接成立 2. 否则，假设第 <span class="math inline">\(k\)</span> 次时，有<span class="math inline">\(\omega(k)^T\overrightarrow{x_i}&lt;0\)</span></p>
<p>然后我们根据算法更新参数 <span class="math display">\[\omega(k+1)=\omega(k)+\overrightarrow{x_i}\]</span> 然后我们有： <span class="math display">\[\omega(k+1)-a\omega_{opt}=\omega(k)-a\omega_{opt}+\overrightarrow{x_i}\]</span> 两边同时取模，则有： <span class="math display">\[
\begin{aligned}
  &amp;{\|\omega(k+1)-a\omega_{opt}\|}^2 \\
= &amp;{\|\omega(k)-a\omega_{opt}+\overrightarrow{x_i}\|}^2 \\
= &amp;{\|\omega(k)-a\omega_{opt}\|}^2+{\|\overrightarrow{x_i}\|}^2+2\omega(k)^T\overrightarrow{x_i}-2a\omega_{opt}^T\overrightarrow{x_i}
\end{aligned}
\]</span> 这里 a 是一个正数，我们之后再具体讨论它的数值。因为 <span class="math inline">\(\omega(k)^T\overrightarrow{x_i}&lt;0\)</span>，因此我们有： <span class="math display">\[
\begin{aligned}
    &amp;{\|\omega(k+1)-a\omega_{opt}\|}^2 \\
\le &amp;{\|\omega(k)-a\omega_{opt}\|}^2+{\|\overrightarrow{x_i}\|}^2-2a\omega_{opt}^T\overrightarrow{x_i}
\end{aligned}
\]</span> 我们定义 <span class="math inline">\(\beta=\max_{i=1}^{N}\lVert\overrightarrow{x_i}\lVert\)</span>，<span class="math inline">\(\gamma=\min_{i=1}^{N}(\omega_{opt}^T\overrightarrow{x_i})\)</span> 易得 <span class="math inline">\(\beta,\gamma&gt;0\)</span>。此时当 <span class="math inline">\(a=\frac{\beta^2+1}{2\gamma}\)</span> 并带入，很容易得到： <span class="math display">\[
{\|\omega(k+1)-a\omega_{opt}\|}^2 \le {\|\omega(k)-a\omega_{opt}\|}^2 -1 
\]</span> 我们定义 <span class="math inline">\(D=\lVert\omega(0)-\omega_{opt}\lVert\)</span>。基于上式我们可以得到，每迭代一次 <span class="math inline">\(\omega\)</span> 与<span class="math inline">\(\omega_{opt}\)</span>的距离减少1，因此至多迭代 <span class="math inline">\(D^2\)</span> 次，<span class="math inline">\(\omega\)</span> 就会收敛到<span class="math inline">\(\omega_{opt}\)</span>。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Proof</tag>
        <tag>Alogrithm</tag>
      </tags>
  </entry>
  <entry>
    <title>git operations</title>
    <url>/Git/git-operations/</url>
    <content><![CDATA[<center>
git operations
</center>
<span id="more"></span>
<ul>
<li><p><strong>设置用户信息</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#x27;TLDX-XIONG&#x27;</span><br><span class="line">git config --global user.email &#x27;tldx@qq.com&#x27;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>生成密钥</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;tldx@qq.com&quot;  # 生成密钥，然后将公钥 id_rsa.pub 添加到 github ssh keys</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git init</code></strong></p>
<p>使用当前目录初始化仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure> 初始化仓库并命名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init [dir]</span><br></pre></td></tr></table></figure> 初始化本地裸仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init --bare  </span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git clone</code></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/TLDX-XIONG/d2l-notebook.git</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git add</code></strong></p>
<p>添加文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [file]</span><br></pre></td></tr></table></figure> 添加文件夹 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure> 添加所有文件到缓存区 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git status</code></strong></p>
<p>查看仓库当前的状态，显示有变更的文件。 <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git commit</code></strong></p>
<p>提交缓存区内容至本地仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;message&#x27;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git remote</code></strong></p>
<p>显示所有远程仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure> 添加远程版本库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:TLDX-XIONG/d2l-notebook.git</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git fetch</code></strong></p>
<p>获取远程库的更新数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git merge</code></strong></p>
<p>将从远程仓库获取的更新数据合并到分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>git pull</code></strong></p>
<p><code>git fetch</code>和<code>git merge</code>的结合版</p>
<p>取回 origin/master 分支，再与本地的 master(默认可不写) 分支合并 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><a href="https://missing-semester-cn.github.io/2020/version-control/">Git 参考链接</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>add gitbash icon</title>
    <url>/Git/add-gitbash-icon/</url>
    <content><![CDATA[<center>
右键添加Git Bash Here
</center>
<span id="more"></span>
<ol type="1">
<li><p>第一步，window + R，输入regedit回车进入注册表</p></li>
<li><p>依次进入HKEY_CLASSES_ROOT —-》 Directory —-》Background —-》 shell</p></li>
<li><p>右键点击shell，选择新建，然后选择项，命名为 Git Bash Here，成功后进入桌面右键发现多了 Git Bash Here. <img src="/Git/add-gitbash-icon/git_1.png"></p></li>
<li><p>添加图标：右键点击shell中你刚刚新建的这个项(Git Bash Here)，选择新建，然后选择字符串值，将名称设置为Icon；</p></li>
<li><p>然后找一下你安装Git的文件夹，我是安装在了E盘，<code>E:softwares\git\Git\mingw64\share\git</code>，按照这个路径进入到git文件夹，会发现里面有个<code>git-for-windows.ico</code>；然后将刚刚新建的字符串值的数据设置为<code>E:softwares\git\Git\mingw64\share\git\git-for-windows.ico</code>；保存发现右键Git Bash Here中多了一个图标； <img src="/Git/add-gitbash-icon/git_2.png"></p></li>
<li><p>接下来还差最后一步，在 Git Bash Here 下面新建一个项，名字为command。 <img src="/Git/add-gitbash-icon/git_3.png"></p></li>
</ol>
<p>将数据设置成 <code>E:softwares\git\Git\bin\bash.exe –login -i</code>，这个也和你安装Git的路径有关，我是安装在了E盘；</p>
<p>设置完之后，好了，大功告成！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode solution</title>
    <url>/leetcode/leetcode-solution/</url>
    <content><![CDATA[<center>
leetcode 每日一题题解
</center>
<span id="more"></span>
<h3 id="简化路径2022.01.06">71.简化路径(2022.01.06)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/simplify-path/">https://leetcode-cn.com/problems/simplify-path/</a></p>
<p>思路：先以<code>/</code>作为分隔符将字符串切割，切割后存在以下四种情况：<code>..</code>，<code>.</code>，<code>xx</code>和空。</p>
<ul>
<li>对于<code>..</code>，我们使用栈用于弹出最后添加的目录</li>
<li>对于<code>.</code>和空，我们不需处理</li>
<li>对于<code>xx</code>，我们将其添加到栈中即可。</li>
</ul>
<p>题解： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        names = path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> name ==<span class="string">&#x27;..&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> name <span class="keyword">and</span> name != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                stack.append(name)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span>+<span class="string">&#x27;/&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure></p>
<h3 id="括号的最大深度2022.01.07">1614.括号的最大深度(2022.01.07)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/</a></p>
<p>思路：建立一个栈，遍历字符串，遇到<code>(</code>便将其入栈；遇到<code>)</code>时，保存此时栈中的大小，再将栈顶<code>(</code>弹出以匹配<code>)</code>。栈中大小的最大值，即为嵌套深度。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : s)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ++size;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch ==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                count = <span class="built_in">max</span>(size, count);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="格雷编码2022.01.08">89.格雷编码(2022.01.08)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/gray-code/">https://leetcode-cn.com/problems/gray-code/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = ans.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len<span class="number">-1</span>; j &gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(ans[j]|(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)));</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="按键持续时间最长的键2022.01.09">1629.按键持续时间最长的键(2022.01.09)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/slowest-key/">https://leetcode-cn.com/problems/slowest-key/</a></p>
<p>思路：一次遍历<code>keysPressed</code>和<code>releaseTimes</code>，记录按键和按键的持续时间。</p>
<p>为避免越界问题，首先记录第0个按键，持续时间为<code>releaseTimes[0]</code>，按下的键为keysPressed[0]，将其记为按键持续的最长时间和对应的按键。然后遍历其余按键更新最大持续时间和对应的按键。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">slowestKey</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; releaseTimes, string keysPressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = keysPressed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">char</span> ans = keysPressed[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxTime = releaseTimes[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> key = keysPressed[i];</span><br><span class="line">            <span class="keyword">int</span> time = releaseTimes[i] - releaseTimes[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>((time &gt; maxTime)||(time == maxTime &amp;&amp; key &gt; ans))&#123;</span><br><span class="line">                ans = key;</span><br><span class="line">                maxTime = time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="累加数2022.01.10">306.累加数(2022.01.10)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/additive-number/">https://leetcode-cn.com/problems/additive-number/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAdditiveNumber</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> secondStart = <span class="number">1</span>; secondStart &lt; n - <span class="number">1</span>; ++secondStart) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; secondStart != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> secondEnd = secondStart; secondEnd &lt; n - <span class="number">1</span>; ++secondEnd) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[secondStart] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; secondStart != secondEnd) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">valid</span>(secondStart, secondEnd, num)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> secondStart, <span class="keyword">int</span> secondEnd, string num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> firstStart = <span class="number">0</span>, firstEnd = secondStart - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (secondEnd &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            string third = <span class="built_in">stringAdd</span>(num, firstStart, firstEnd, secondStart, secondEnd);</span><br><span class="line">            <span class="keyword">int</span> thirdStart = secondEnd + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> thirdEnd = secondEnd + third.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (thirdEnd &gt;= n || !(num.<span class="built_in">substr</span>(thirdStart, thirdEnd - thirdStart + <span class="number">1</span>) == third)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (thirdEnd == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstStart = secondStart;</span><br><span class="line">            firstEnd = secondEnd;</span><br><span class="line">            secondStart = thirdStart;</span><br><span class="line">            secondEnd = thirdEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">stringAdd</span><span class="params">(string s, <span class="keyword">int</span> firstStart, <span class="keyword">int</span> firstEnd, <span class="keyword">int</span> secondStart, <span class="keyword">int</span> secondEnd)</span> </span>&#123;</span><br><span class="line">        string third;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (firstEnd &gt;= firstStart || secondEnd &gt;= secondStart || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = carry;</span><br><span class="line">            <span class="keyword">if</span> (firstEnd &gt;= firstStart) &#123;</span><br><span class="line">                cur += s[firstEnd] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                --firstEnd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (secondEnd &gt;= secondStart) &#123;</span><br><span class="line">                cur += s[secondEnd] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                --secondEnd;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            third.<span class="built_in">push_back</span>(cur + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(third.<span class="built_in">begin</span>(), third.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="逃离大迷宫2022.01.11">1036.逃离大迷宫(2022.01.11)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/escape-a-large-maze/">https://leetcode-cn.com/problems/escape-a-large-maze/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在包围圈中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> BLOCKED = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 不在包围圈中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> VALID = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 无论在不在包围圈中，但在 n(n-1)/2 步搜索的过程中经过了 target</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> FOUND = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> BOUNDARY = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEscapePossible</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; blocked, vector&lt;<span class="keyword">int</span>&gt;&amp; source, vector&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blocked.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> hash_fn = [fn = hash&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;()](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; o) -&gt; <span class="keyword">size_t</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; [x, y] = o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fn</span>((<span class="keyword">long</span> <span class="keyword">long</span>)x &lt;&lt; <span class="number">20</span> | y);</span><br><span class="line">        &#125;;</span><br><span class="line">        unordered_set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(hash_fn)&gt; <span class="built_in">hash_blocked</span>(<span class="number">0</span>, hash_fn);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pos: blocked) &#123;</span><br><span class="line">            hash_blocked.<span class="built_in">emplace</span>(pos[<span class="number">0</span>], pos[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; start, vector&lt;<span class="keyword">int</span>&gt;&amp; finish) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> sx = start[<span class="number">0</span>], sy = start[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> fx = finish[<span class="number">0</span>], fy = finish[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> countdown = blocked.<span class="built_in">size</span>() * (blocked.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            q.<span class="built_in">emplace</span>(sx, sy);</span><br><span class="line">            unordered_set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(hash_fn)&gt; <span class="built_in">visited</span>(<span class="number">0</span>, hash_fn);</span><br><span class="line">            visited.<span class="built_in">emplace</span>(sx, sy);</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; countdown &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + dirs[d][<span class="number">0</span>], ny = y + dirs[d][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; BOUNDARY &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; BOUNDARY &amp;&amp; !hash_blocked.<span class="built_in">count</span>(&#123;nx, ny&#125;) &amp;&amp; !visited.<span class="built_in">count</span>(&#123;nx, ny&#125;)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nx == fx &amp;&amp; ny == fy) &#123;</span><br><span class="line">                            <span class="keyword">return</span> FOUND;</span><br><span class="line">                        &#125;</span><br><span class="line">                        --countdown;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(nx, ny);</span><br><span class="line">                        visited.<span class="built_in">emplace</span>(nx, ny);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (countdown &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> BLOCKED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> VALID;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> result = <span class="built_in">check</span>(source, target); result == FOUND) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == BLOCKED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">check</span>(target, source);</span><br><span class="line">            <span class="keyword">if</span> (result == BLOCKED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="递增的三元子序列2022.01.12">334.递增的三元子序列(2022.01.12)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">https://leetcode-cn.com/problems/increasing-triplet-subsequence/</a></p>
<p>思路：从左到右遍历数组，维护两个变量 <code>first</code> 和 <code>second</code>，分别表示三元子序列的第一个，第二个数，且有 <code>first</code> &lt; <code>second</code>。</p>
<p>初始时，<code>first</code> = <code>num[0]</code>，<code>second</code> = +∞。对于 1 &lt;= i &lt; n，当遍历到下标 i 时： 1. 如果 <code>nums[i]</code> &gt; <code>second</code>，则找到了一个递增的三原子序列 2. 否则，如果 <code>nums[i]</code> &gt; <code>first</code>，则令 <code>second</code> = <code>nums[i]</code> 3. 否则，<code>first</code> = <code>nums[i]</code></p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> second = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; first) second = nums[i];</span><br><span class="line">            <span class="keyword">else</span> first = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="至少是其他数字两倍的最大数2022.01.13">747.至少是其他数字两倍的最大数(2022.01.13)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/">https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/</a></p>
<p>思路：遍历数组，找到数组中的最大值 <code>max1</code> 和次大值 <code>max2</code>。判断 <code>max1</code> 是否大于或等于 <code>max2</code> 的两倍。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> max1 = <span class="number">-1</span>, max2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max1)&#123;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; max2) max2 = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max1 &gt;= (max2*<span class="number">2</span>) ? index : <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="查找和最小的-k-对数字2022.01.14">373.查找和最小的 K 对数字(2022.01.14)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/</a></p>
<p>思路：构建堆，因为两个数组已经有序，故遍历两个数组，求和，将结果加入堆中。弹出前 K 个最值。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;   </span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(k, m); i++) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = pq.<span class="built_in">top</span>(); </span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(initializer_list&lt;<span class="keyword">int</span>&gt;&#123;nums1[x], nums2[y]&#125;);</span><br><span class="line">            <span class="keyword">if</span> (y + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(x, y + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="计算力扣银行存的钱2022.01.15">1716.计算力扣银行存的钱(2022.01.15)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/</a></p>
<p>思路：每周存的前是一个等差数列，故可以直接计算整数个周存的前，之后再计算最后不足一周存的钱，也可以通过等差数列计算。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalMoney</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有完整的周存的钱</span></span><br><span class="line">        <span class="keyword">int</span> weekNumber = n / <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> firstWeekMoney = (<span class="number">1</span> + <span class="number">7</span>) * <span class="number">7</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lastWeekMoney = firstWeekMoney + <span class="number">7</span> * (weekNumber - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> weekMoney = (firstWeekMoney + lastWeekMoney) * weekNumber / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 剩下的不能构成一个完整的周的天数里存的钱</span></span><br><span class="line">        <span class="keyword">int</span> dayNumber = n % <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> firstDayMoney = <span class="number">1</span> + weekNumber;</span><br><span class="line">        <span class="keyword">int</span> lastDayMoney = firstDayMoney + dayNumber - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dayMoney = (firstDayMoney + lastDayMoney) * dayNumber / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> weekMoney + dayMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="链表随机节点2022.01.16">382.链表随机节点(2022.01.16)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/linked-list-random-node/">https://leetcode-cn.com/problems/linked-list-random-node/</a></p>
<p>思路：使用数组存储链表的所有元素，直接通过下标返回随机索引值。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode *head) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="built_in">rand</span>() % arr.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="统计元音字母序列的数目2022.01.17">1220.统计元音字母序列的数目(2022.01.17)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/count-vowels-permutation/">https://leetcode-cn.com/problems/count-vowels-permutation/</a></p>
<p>思路：使用动态规划的思想</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">ndp</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="comment">/* a前面可以为e,u,i */</span></span><br><span class="line">            ndp[<span class="number">0</span>] = (dp[<span class="number">1</span>] + dp[<span class="number">2</span>] + dp[<span class="number">4</span>]) % mod;</span><br><span class="line">            <span class="comment">/* e前面可以为a,i */</span></span><br><span class="line">            ndp[<span class="number">1</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">2</span>]) % mod;</span><br><span class="line">            <span class="comment">/* i前面可以为e,o */</span></span><br><span class="line">            ndp[<span class="number">2</span>] = (dp[<span class="number">1</span>] + dp[<span class="number">3</span>]) % mod;</span><br><span class="line">            <span class="comment">/* o前面可以为i */</span></span><br><span class="line">            ndp[<span class="number">3</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">/* u前面可以为i,o */</span></span><br><span class="line">            ndp[<span class="number">4</span>] = (dp[<span class="number">2</span>] + dp[<span class="number">3</span>]) % mod;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0LL</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="最小时间差2022.01.18">539.最小时间差(2022.01.18)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/minimum-time-difference/">https://leetcode-cn.com/problems/minimum-time-difference/</a></p>
<p>思路：将 timePoints 进行排序，然后遍历一遍数组记录最小的时间差。另外，根据题意，一共会有 24*60 = 1440 中不同的时间。因此如果 timePoints 长度超过了 1440，那么必然会有两个相同的时间，可以直接返回 0。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinutes</span><span class="params">(string &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>)) * <span class="number">60</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt; &amp;timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = timePoints.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1440</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(timePoints.<span class="built_in">begin</span>(), timePoints.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> t0Minutes = <span class="built_in">getMinutes</span>(timePoints[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> preMinutes = t0Minutes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minutes = <span class="built_in">getMinutes</span>(timePoints[i]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, minutes - preMinutes); <span class="comment">// 相邻时间的时间差</span></span><br><span class="line">            preMinutes = minutes;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, t0Minutes + <span class="number">1440</span> - preMinutes); <span class="comment">// 首尾时间的时间差</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="存在重复元素2022.01.19">219.存在重复元素(2022.01.19)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">https://leetcode-cn.com/problems/contains-duplicate-ii/</a></p>
<p>思路：遍历 nums，使用哈希存储值和索引 i，每添加一个元素时，判断是否存在该元素以及判断 i-j &lt;= k 是否成立，成立则返回 true。</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dictionary;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dictionary.<span class="built_in">count</span>(num) &amp;&amp; i - dictionary[num] &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            dictionary[num] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="石子游戏ⅸ2022.01.20">2029.石子游戏Ⅸ(2022.01.20)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/stone-game-ix/">https://leetcode-cn.com/problems/stone-game-ix/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGameIX</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val: stones) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">int</span> type = val % <span class="number">3</span>; type == <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">                ++cnt1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cnt2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt0 % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt1 &gt;= <span class="number">1</span> &amp;&amp; cnt2 &gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt1 - cnt2 &gt; <span class="number">2</span> || cnt2 - cnt1 &gt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除回文子序列2022.01.22">1332.删除回文子序列(2022.01.22)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">https://leetcode-cn.com/problems/remove-palindromic-subsequences/</a></p>
<p>思路：就两种情况：如果是字符串是回文串，则返回 1；否则返回 2；</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removePalindromeSub</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[n - <span class="number">1</span> - i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="股票价格波动2022.01.23">2034.股票价格波动(2022.01.23)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/stock-price-fluctuation/">https://leetcode-cn.com/problems/stock-price-fluctuation/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockPrice</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxTimestamp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        maxTimestamp = <span class="built_in">max</span>(maxTimestamp, timestamp);</span><br><span class="line">        <span class="keyword">int</span> prevPrice = timePriceMap.<span class="built_in">count</span>(timestamp) ? timePriceMap[timestamp] : <span class="number">0</span>;</span><br><span class="line">        timePriceMap[timestamp] = price;</span><br><span class="line">        <span class="keyword">if</span> (prevPrice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = prices.<span class="built_in">find</span>(prevPrice);</span><br><span class="line">            <span class="keyword">if</span> (it != prices.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                prices.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prices.<span class="built_in">emplace</span>(price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timePriceMap[maxTimestamp];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *prices.<span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *prices.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxTimestamp;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; timePriceMap;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; prices;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="检测正方形2022.01.26">2013.检测正方形(2022.01.26)</h3>
<p>链接：https://leetcode-cn.com/problems/detect-squares/</p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectSquares</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">    <span class="built_in">DetectSquares</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        cnt[y][x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!cnt.<span class="built_in">count</span>(y)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; yCnt = cnt[y];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [col, colCnt] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col != y) &#123;</span><br><span class="line">                <span class="comment">// 根据对称性，这里可以不用取绝对值</span></span><br><span class="line">                <span class="keyword">int</span> d = col - y;</span><br><span class="line">                res += (colCnt.<span class="built_in">count</span>(x) ? colCnt[x] : <span class="number">0</span>) * (yCnt.<span class="built_in">count</span>(x + d) ? yCnt[x + d] : <span class="number">0</span>) * </span><br><span class="line">                       (colCnt.<span class="built_in">count</span>(x + d)? colCnt[x + d] : <span class="number">0</span>);</span><br><span class="line">                res += (colCnt.<span class="built_in">count</span>(x) ? colCnt[x] : <span class="number">0</span>) * (yCnt.<span class="built_in">count</span>(x - d) ? yCnt[x - d] : <span class="number">0</span>) * </span><br><span class="line">                       (colCnt.<span class="built_in">count</span>(x - d) ? colCnt[x - d] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="句子中的有效单词数2022.01.27">2047.句子中的有效单词数(2022.01.27)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/">https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countValidWords</span>(<span class="params">self, sentence: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            hasHyphens = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">                <span class="keyword">if</span> ch.isdigit() <span class="keyword">or</span> ch <span class="keyword">in</span> <span class="string">&quot;!.,&quot;</span> <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> hasHyphens <span class="keyword">or</span> i == <span class="number">0</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> s[i - <span class="number">1</span>].islower() <span class="keyword">or</span> <span class="keyword">not</span> s[i + <span class="number">1</span>].islower():</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    hasHyphens = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(valid(s) <span class="keyword">for</span> s <span class="keyword">in</span> sentence.split())</span><br></pre></td></tr></table></figure></p>
<h3 id="地图中的最高点2022.01.29">176.地图中的最高点(2022.01.29)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/map-of-highest-peak/">https://leetcode-cn.com/problems/map-of-highest-peak/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">highestPeak</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;isWater) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = isWater.<span class="built_in">size</span>(), n = isWater[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>)); <span class="comment">// -1 表示该格子尚未被访问过</span></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isWater[i][j]) &#123;</span><br><span class="line">                    ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i, j); <span class="comment">// 将所有水域入队</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;p = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p.first + dir[<span class="number">0</span>], y = p.second + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; m &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; n &amp;&amp; ans[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    ans[x][y] = ans[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="两句话中的不常见单词2022.01.30">884.两句话中的不常见单词(2022.01.30)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/">https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uncommonFromSentences</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        freq = Counter(s1.split()) + Counter(s2.split())</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> word, occ <span class="keyword">in</span> freq.items():</span><br><span class="line">            <span class="keyword">if</span> occ == <span class="number">1</span>:</span><br><span class="line">                ans.append(word)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h3 id="将数字变为-0-的操作次数2022.01.31">1342.将数字变为 0 的操作次数(2022.01.31)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/">https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSteps</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span>) num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> --num;</span><br><span class="line"></span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="有序数组中的单一元素2022.02.14">540.有序数组中的单一元素(2022.02.14)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid ^ <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="比特于2比特字符2022.2.20">717. 1比特于2比特字符(2022.2.20)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/">https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += bits[i] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="反转字母2022.2.23">917. 反转字母(2022.2.23)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/reverse-only-letters/">https://leetcode-cn.com/problems/reverse-only-letters/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseOnlyLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; !<span class="built_in">isalpha</span>(s[left])) left++;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; !<span class="built_in">isalpha</span>(s[right])) right--;</span><br><span class="line">            <span class="built_in">swap</span>(s[left], s[right]);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="顺次数2022.2.23">1291. 顺次数(2022.2.23)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/sequential-digits/">https://leetcode-cn.com/problems/sequential-digits/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sequentialDigits</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + j;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= low &amp;&amp; num &lt;= high) ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="增量元素之间的最大差值2022.2.26">2016. 增量元素之间的最大差值(2022.2.26)</h3>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/">https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/</a></p>
<p>思路：</p>
<p>题解： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre_min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; pre_min) ans = <span class="built_in">max</span>(ans, nums[i] - pre_min);</span><br><span class="line">            <span class="keyword">else</span> pre_min =<span class="built_in">min</span>(pre_min, nums[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>solutions</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>everything http sever</title>
    <url>/configuration/everything-http-sever/</url>
    <content><![CDATA[<center>
everything 配置 HTTP Server 以及内网穿透
</center>
<span id="more"></span>
<p>可以利用 everything package 将本机作为服务器供他人访问文件，要求是需要在同一局域网下。因此为了解决此问题，可以引入内网穿透机制，使得其能够痛过外网访问。这里我使用了花生壳作为内网穿透工具。</p>
<p>我的地址为：<a href="http://46845i377b.zicp.vip">http://46845i377b.zicp.vip</a></p>
]]></content>
      <categories>
        <category>configuration</category>
      </categories>
      <tags>
        <tag>http server</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-cmd</title>
    <url>/Linux/linux-cmd/</url>
    <content><![CDATA[<center>
Linux and Shell
</center>
<span id="more"></span>
<h3 id="linux-常用命令总结">Linux 常用命令总结</h3>
<ul>
<li><code>cd dir</code> <strong>切换目录</strong>
<ul>
<li><code>~</code>：回到 home 目录</li>
</ul></li>
<li><code>pwd</code>：<strong>查看目录绝对路径</strong></li>
<li><code>clear</code>：<strong>清屏命令</strong></li>
<li><code>mkdir -m -p dir</code> <strong>创建目录</strong> 其中 <code>-m</code> 代表权限 <code>-p</code> 代表如果目录不存在则创建一个，不会报错。</li>
<li><code>ls [options]</code> <strong>列出目录</strong>
<ul>
<li><code>-a</code> 列出所有文件包括 <code>·</code> 和 <code>··</code></li>
<li><code>-l</code> 列出详细信息</li>
<li><code>-r</code> 倒序显示</li>
<li><code>-t</code> 按时间显示</li>
</ul></li>
<li><code>rmdir dir</code> <strong>删除空目录</strong></li>
<li><code>tree</code> <strong>以树状图列出文件</strong></li>
<li><code>mv source dest</code> <strong>移动文件</strong></li>
<li>将源文件或目录移动到目标目录下，如果不存在，则为重命名源文件或目录</li>
<li><code>rm [options]</code> <strong>删除文件或目录</strong>
<ul>
<li><code>-i</code> 删除文件时询问是否删除</li>
<li><code>-r</code> 删除该目录下的所有文件</li>
</ul></li>
<li><code>cp [options] [source] [dest]</code> <strong>复制文件和目录</strong>
<ul>
<li><code>-r</code> 复制目录下的所有文件</li>
<li><code>-i</code> 覆盖时候询问是否覆盖</li>
</ul></li>
<li><code>zip</code> <strong>压缩文件</strong>
<ul>
<li><code>-r</code> 递归处理压缩</li>
<li><code>-q</code> 隐藏指令执行过程</li>
</ul></li>
<li><code>unzip</code> <strong>解压文件</strong>
<ul>
<li><code>-d</code> 解压后存储的目录</li>
<li><code>-v</code> 查看压缩文件信息</li>
<li><code>-l</code> 查看压缩文件包含的文件</li>
</ul></li>
<li><code>tar [-czvf] compressname dir</code> <strong>压缩文件</strong></li>
<li><code>tar [-xvf] compressname -C dir</code> <strong>解压文件</strong></li>
<li><code>tar [-xzvf] compressname -C dir</code><strong>解压.gz文件</strong></li>
<li><code>find [path]</code> <strong>查找文件</strong>
<ul>
<li><code>name</code> 指定查找的文件</li>
<li><code>type</code> 文件类型</li>
</ul></li>
<li><code>xargs</code> <strong>连接两个命令</strong>
<ul>
<li><code>[source_command] | xargs -d '\n' [dest_command]</code></li>
<li><code>find . -name "*.py" | xargs -d '\n' rm</code></li>
</ul></li>
</ul>
<h3 id="shell">Shell</h3>
<ul>
<li><p><code>date</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ date</span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br><span class="line">missing:~$ </span><br></pre></td></tr></table></figure></p></li>
<li><p><code>echo</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello</span><br><span class="line">foo=bar    # 变量赋值</span><br><span class="line">echo $foo  # 引用变量输出</span><br><span class="line">echo &quot;hello, $foo&quot; # 双引号格式化输出字符串，会自动替换</span><br><span class="line">echo &#x27;hello, $foo&#x27; # 单引号直接输出字符串，不执行格式化</span><br><span class="line">echo hello &gt; hello.txt  # 将输出重定向到 hello.txt</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>cat</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ echo hello &gt; hello.txt</span><br><span class="line">missing:~$ cat hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt # 重定向输入为 hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt &gt; hello2.txt # 重定向输入为 hello.txt，输出为 hello2.txt</span><br><span class="line">missing:~$ cat hello2.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat hello.txt &gt;&gt; hello2.txt # 使用 &gt;&gt; 追加内容</span><br><span class="line">missing:~$ cat hello2.txt</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>which</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which echo # 定位程序所在的路径</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>man</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man ls  # 用户手册，查看命令使用方法</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>tldr</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tldr ls # 更好用的用户手册是 tldr</span><br></pre></td></tr></table></figure></p></li>
<li><p><em>pipes</em> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ ls -l / | tail -n1 # 使用 pipe 将一个</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2</span><br><span class="line">219</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>ps</code> 显示所有的进程</p></li>
<li><p><code>jobs</code> 显示所有的工作</p></li>
<li><p><code>bg %&#123;job_id&#125;</code> 将 job_id 放入后台执行</p></li>
<li><p><code>fg %&#123;job_id&#125;</code> 将 job_id 放到前台执行</p></li>
<li><p><code>kill</code> 向进程发送命令 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -l # 列出所有可发送的信号</span><br><span class="line">kill 9 &#123;porcess_id&#125; # 发送信号 9 给 进程 process_id</span><br><span class="line">kill -9 &#123;group_id&#125; # 发送信号 9 给 group_id 中的所有进程</span><br><span class="line">kill -9 %&#123;job_id&#125;  # 发送信号 9 给工作 job_id </span><br></pre></td></tr></table></figure></p></li>
<li><p><code>tmux</code> <strong>终端多路复用器</strong></p>
<ul>
<li><strong>会话</strong>，每一个会话都是一个独立的工作区，其中可以包含多个窗口
<ul>
<li><code>tmux</code> 开始一个新的会话</li>
<li><code>tmux new -s &#123;name&#125;</code> 以指定名字开始一个新的会话</li>
<li><code>tmux ls</code> 列出所有的会话</li>
<li><code>Ctrl-b d</code> 在会话中输入 <code>Ctrl-b d</code>，将当前会话分离</li>
<li><code>tmux a</code> 重新连接最后一个会话</li>
<li><code>tmux a -t &#123;n&#125;</code> 连接指定的会话 n</li>
</ul></li>
<li><strong>窗口</strong>
<ul>
<li><code>Ctrl-b c</code> 创建一个新的窗口，使用 <code>Ctrl-d</code> 关闭</li>
<li><code>Ctrl-b N</code> 跳转到第 N 个窗口</li>
<li><code>Ctrl-b p</code> 切换到上一个窗口</li>
<li><code>Ctrl-b n</code> 切换到下一个窗口</li>
<li><code>Ctrl-b ,</code> 重命名当前窗口</li>
<li><code>Ctrl-b w</code> 列出当前所有窗口</li>
</ul></li>
<li><strong>面板</strong> 分屏，使得一个屏幕显示多个shell
<ul>
<li><code>Ctrl-b "</code> 水平分割</li>
<li><code>Ctrl-b %</code> 垂直分割</li>
<li><code>Ctrl-b &lt;方向&gt;</code> 切换到指定方向的面板</li>
<li><code>Ctrl-b z</code> 切换当前面板的缩放</li>
<li><code>Ctrl-b &lt;空格&gt;</code> 在不同面板布局间切换</li>
</ul></li>
</ul></li>
<li><p><code>别名</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias ll=&quot;ls -l&quot;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>ssh</code> 远程连接服务器</p>
<ul>
<li><code>ssh foo@bar.mit.edu</code> 使用域名</li>
<li><code>ssh foo@192.168.1.42</code> 使用 ip</li>
<li>使用密钥 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一对密钥</span></span><br><span class="line">ssh-keygen -o -a 100 -t ed25519.pub -f ~/.ssh/id_ed25519 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将公钥发送到远端</span></span><br><span class="line">cat ~/.ssh/id_ed25519 | ssh foo@bar.mit.edu &#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用下面命令(如果支持的话)</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_ed25519.pub foo@bar.mit.edu</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc compiler</title>
    <url>/gcc/gcc-compiler/</url>
    <content><![CDATA[<center>
gcc 编译器命令
</center>
<span id="more"></span>
<ol type="1">
<li>gcc 编译程序过程包含
<ul>
<li>预处理(.i文件)</li>
<li>编译(.S文件)</li>
<li>汇编(.o文件)</li>
<li>链接(可执行文件)</li>
</ul></li>
</ol>
<pre class="mermaid">graph LR
main.c --> |预处理|main.i --> |编译|main.S --> |汇编|main.o
start.c --> |预处理|start.i --> |编译|start.S --> |汇编|start.o
main.o --> |链接| main可执行文件
start.o --> |链接|main可执行文件</pre>
<ol start="2" type="1">
<li>编译过程
<ul>
<li>预处理：<code>gcc -E hello.c -o hello.i</code></li>
<li>编 译：<code>gcc -S hello.i -o hello.s</code></li>
<li>汇 编：<code>gcc -c hello.s -o hello.o</code></li>
<li>链 接：<code>gcc hello.o xxx.o -o hello</code></li>
</ul></li>
<li>常见使用示例
<ul>
<li><code>gcc hello.c</code> <em>直接输出为二进制文件 <code>a.out</code>，通过 <code>./a.out</code> 执行</em></li>
<li><code>gcc hello.c -o hello</code> <em>输出名为 <code>hello</code> 的可执行文件，通过 <code>./hello</code> 执行</em></li>
<li><code>gcc -c hello.c</code> <em>输出 <code>hello.o</code> 文件，用于链接</em></li>
<li><code>gcc hello.o main.o -o main</code> <em>链接多个编译文件，生成 <code>main</code> 可执行文件</em></li>
</ul></li>
<li>编译常用选项
<ul>
<li>-Wall <em>打印警告信息</em></li>
<li>-w <em>忽略所有警告信息</em></li>
<li>-O1，-O2，-O3 <em>表示程序优化等级，O3 最高</em></li>
<li>-g <em>用来产生调试信息，供 gdb 调试器使用</em></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-cmd</title>
    <url>/Linux/Vim-cmd/</url>
    <content><![CDATA[<center>
vim 教程
</center>
<span id="more"></span>
<h2 id="vim-操作模式">1 vim 操作模式</h2>
<ul>
<li>正常模式：在文件中四处移动光标修改</li>
<li>插入模式：插入文本</li>
<li>替换模式：替换文本</li>
<li>可视化 { 一般，行，块} 模式：选中文本块</li>
<li>命令模式：执行命令</li>
</ul>
<p>下面是 vim 操作模式的切换方法图</p>
<pre class="mermaid">graph
Normal --i--> Insert
Normal --R--> Replace
Normal --v--> Visual
Normal --shift-v--> Visual-line
Normal --ctrl-v--> Visual-block
Normal --:--> Command-line</pre>
<p>值得注意的是，可以从任何模式按下 <code>&lt;ESC&gt;</code> 退出到正常模式下。</p>
<h2 id="基本操作">2 基本操作</h2>
<h3 id="插入模式">2.1 插入模式</h3>
<ul>
<li>键入 <code>i</code> 进入插入模式，与其它编辑器一样操作。</li>
<li>键入 <code>&lt;ESC&gt;</code> 返回正常模式。</li>
</ul>
<h3 id="命令行模式">2.2 命令行模式</h3>
<p>使用 <code>:</code> 进入命令行模式</p>
<ul>
<li><p><code>:q</code> 退出(不保存)</p></li>
<li><p><code>:w</code> 保存</p></li>
<li><p><code>:wq</code> 保存然后退出</p></li>
<li><p><code>:e &#123;文件名&#125;</code> 打开要编辑的文件</p></li>
<li><p><code>:ls</code> 显示打开的缓存</p></li>
<li><p><code>:help &#123;command&#125;</code> 打开帮助文档</p>
<ul>
<li><code>:help :w</code> 打开 <code>:w</code> 的帮助文档</li>
<li><code>:help w</code> 打开 <code>w</code> 的帮助文档</li>
</ul></li>
<li><p><code>/&#123;word&#125;</code> 检索单词， 使用 n 转到下一个， N 转到上一个</p></li>
<li><p><code>:%s/old/new/g</code> 替换 <code>old</code> 字符串为 <code>new</code> <code>g</code> 代表全局替换 ### 2.3 可视化模式</p></li>
<li><p>可视化：按 <code>v</code>进入之后，使用移动命令进行选中</p></li>
<li><p>可视化行：按 <code>shift-v</code> 进入，一次选中一行</p></li>
<li><p>可视化块：按 <code>shift-v</code> 进入，支持选中块 ### 2.4 正常模式</p></li>
</ul>
<h4 id="移动">2.4.1 移动</h4>
<ul>
<li>基本移动
<ul>
<li><code>h</code> 左</li>
<li><code>j</code> 下</li>
<li><code>k</code> 上</li>
<li><code>l</code> 右</li>
</ul></li>
<li>词
<ul>
<li><code>w</code> 下一个词</li>
<li><code>b</code> 上一个词初</li>
<li><code>e</code> 词尾</li>
</ul></li>
<li>行：
<ul>
<li><code>0</code> 行初</li>
<li><code>^</code> 第一个非空字符</li>
<li><code>$</code> 行尾</li>
<li><code>A</code> 行尾并开启插入模式</li>
</ul></li>
<li>屏幕：
<ul>
<li><code>H</code> 屏幕首行</li>
<li><code>M</code> 屏幕中间</li>
<li><code>L</code> 屏幕底部</li>
</ul></li>
<li>翻页：
<ul>
<li><code>Ctrl-u</code> 上翻</li>
<li><code>Ctrl-d</code> 下翻</li>
</ul></li>
<li>文件：
<ul>
<li><code>gg</code> 文件头</li>
<li><code>G</code> 文件尾</li>
</ul></li>
</ul>
<h4 id="编辑">2.4.2 编辑</h4>
<ul>
<li><code>x</code> 删除光标下的字符</li>
<li><code>O</code> / <code>o</code> 在上面 / 下面 插入行</li>
<li><code>d[移动命令]</code> 删除[移动命令]</li>
<li><code>dd</code> 删除整行
<ul>
<li>例如，<code>dw</code> 删除一个词， <code>d$</code> 删除到行尾，<code>d0</code> 删除到行头</li>
</ul></li>
<li><code>c[移动命令]</code> 改变[移动命令] <strong>与 d 的区别在于，c 进入插入模式</strong>
<ul>
<li><code>cw</code> 改变词</li>
</ul></li>
<li>可视化模式 + 操作
<ul>
<li>选中文字 + <code>d</code> / <code>c</code></li>
</ul></li>
<li><code>u</code> 撤销</li>
<li><code>Ctrl-R</code> 反撤销</li>
<li><code>y</code> 复制(yank)</li>
<li><code>p</code> 粘贴</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
</search>
